<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>chartForge Renderer Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    body {
      font-family: 'Lato', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
    }

    .app-container {
      display: flex;
      height: 100vh;
    }

    /* Left Panel - Editor */
    .editor-panel {
      width: 50%;
      min-width: 300px;
      display: flex;
      flex-direction: column;
      background: white;
      border-right: 1px solid #ddd;
    }

    .editor-header {
      padding: 12px 16px;
      border-bottom: 1px solid #eee;
      background: #fafafa;
    }

    .editor-header h1 {
      margin: 0;
      font-size: 18px;
      color: #333;
    }

    .toolbar {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      border-bottom: 1px solid #eee;
      align-items: center;
      flex-wrap: wrap;
    }

    .search-container {
      position: relative;
      flex: 1;
      min-width: 200px;
    }

    .search-input {
      width: 100%;
      padding: 8px 12px;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: white;
    }

    .search-input:focus {
      outline: none;
      border-color: #4a4a4a;
      box-shadow: 0 0 0 2px rgba(74, 74, 74, 0.2);
    }

    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: white;
      border: 1px solid #ccc;
      border-top: none;
      border-radius: 0 0 6px 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 100;
      display: none;
    }

    .search-results.visible {
      display: block;
    }

    .search-result {
      padding: 10px 14px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }

    .search-result:last-child {
      border-bottom: none;
    }

    .search-result:hover,
    .search-result.selected {
      background: #f0f0f0;
    }

    .search-result .title {
      font-weight: 500;
      color: #333;
    }

    .search-result .artist {
      font-size: 12px;
      color: #666;
      margin-top: 2px;
    }

    .search-result .key {
      font-size: 11px;
      color: #999;
      float: right;
    }

    .toolbar-btn {
      padding: 8px 12px;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    .toolbar-btn:hover {
      border-color: #999;
      background: #f5f5f5;
    }

    .toolbar-btn-danger {
      color: #c62828;
    }

    .toolbar-btn-danger:hover:not(:disabled) {
      background: #ffebee;
      border-color: #c62828;
    }

    .toolbar-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .toolbar-divider {
      width: 1px;
      height: 24px;
      background: #ddd;
      margin: 0 4px;
    }

    .toolbar select {
      padding: 8px 12px;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
      padding-right: 30px;
    }

    .toolbar select:hover {
      border-color: #999;
    }

    .toolbar select:focus {
      outline: none;
      border-color: #4a4a4a;
      box-shadow: 0 0 0 2px rgba(74, 74, 74, 0.2);
    }

    .editor-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .editor-wrapper {
      position: relative;
      flex: 1;
      overflow: hidden;
    }

    #backdrop, #input {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      font-family: 'Lato', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
      line-height: 1.7;
      padding: 16px;
      margin: 0;
      border: none;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    #backdrop {
      background: #fafafa;
      color: transparent;
      pointer-events: none;
      overflow: auto;
    }

    #backdrop code {
      font-family: inherit;
      color: #2c2c2c;
    }

    #input {
      background: transparent;
      color: transparent;
      caret-color: #333;
      resize: none;
      outline: none;
      overflow: auto;
      z-index: 1;
    }

    /* Syntax highlighting styles */
    .hl-directive { color: #7a5a9e; font-weight: 600; }
    .hl-directive-key { color: #7a5a9e; font-weight: 600; }
    .hl-directive-value { color: #2e7d6e; font-weight: 400; }
    .hl-brace { color: #a8a8a8; }
    .hl-section { color: #c75d2c; font-weight: 700; }
    .hl-section-name { color: #c75d2c; font-weight: 400; }
    .hl-chord { color: #6b7c93; font-weight: 500; }
    .hl-bracket { color: #b8c4ce; }
    .hl-lyric { color: #1a1a1a; font-weight: 400; }

    .error {
      color: #d32f2f;
      background: #ffebee;
      padding: 10px 16px;
      font-size: 13px;
      display: none;
    }

    /* Right Panel - Preview */
    .preview-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #4a4a4a;
      min-width: 400px;
    }

    .preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 16px;
      background: #3a3a3a;
    }

    .page-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .page-controls button {
      padding: 6px 14px;
      font-size: 13px;
      border: 1px solid #666;
      border-radius: 6px;
      background: #4a4a4a;
      color: white;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .page-controls button:hover:not(:disabled) {
      background: #5a5a5a;
      border-color: #777;
    }

    .page-controls button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .page-controls span {
      font-size: 13px;
      color: #ccc;
    }

    .download-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      font-size: 13px;
      border: 1px solid #666;
      border-radius: 6px;
      background: #4a4a4a;
      color: white;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .download-btn:hover {
      background: #5a5a5a;
      border-color: #777;
    }

    .download-btn svg {
      flex-shrink: 0;
    }

    .preview-header select {
      padding: 6px 28px 6px 10px;
      font-size: 13px;
      border: 1px solid #666;
      border-radius: 6px;
      background: #4a4a4a;
      color: white;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23ccc' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }

    .preview-header select:hover {
      background-color: #5a5a5a;
      border-color: #777;
    }

    .preview-header select:focus {
      outline: none;
      border-color: #888;
    }

    .preview-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 20px;
      overflow: auto;
    }

    #chart-canvas {
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      max-width: 100%;
      height: auto;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .app-container {
        flex-direction: column;
      }

      .editor-panel {
        width: 100%;
        height: 50%;
        border-right: none;
        border-bottom: 1px solid #ddd;
      }

      .preview-panel {
        min-width: unset;
        height: 50%;
      }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <div class="app-container">
    <!-- Editor Panel (Left) -->
    <div class="editor-panel">
      <div class="editor-header">
        <h1>chartForge</h1>
      </div>
      <div class="toolbar">
        <div class="search-container">
          <input type="text" class="search-input" id="song-search" placeholder="Search 676 songs..." autocomplete="off">
          <div class="search-results" id="search-results"></div>
        </div>
        <button class="toolbar-btn" id="random-btn">Random</button>
        <div class="toolbar-divider"></div>
        <button class="toolbar-btn" id="new-btn">New</button>
        <button class="toolbar-btn" id="update-btn">Update</button>
        <button class="toolbar-btn toolbar-btn-danger" id="delete-btn">Delete</button>
        <div class="toolbar-divider"></div>
        <select id="render-key">
          <option value="numbers">Numbers</option>
          <option value="C">Key of C</option>
          <option value="Db">Key of Db</option>
          <option value="D">Key of D</option>
          <option value="Eb">Key of Eb</option>
          <option value="E">Key of E</option>
          <option value="F">Key of F</option>
          <option value="Gb">Key of Gb</option>
          <option value="G">Key of G</option>
          <option value="Ab">Key of Ab</option>
          <option value="A">Key of A</option>
          <option value="Bb">Key of Bb</option>
          <option value="B">Key of B</option>
        </select>
      </div>
      <div class="editor-content">
        <div class="editor-wrapper">
          <pre id="backdrop" aria-hidden="true"><code id="highlight"></code></pre>
          <textarea id="input" spellcheck="false"></textarea>
        </div>
        <div class="error" id="error"></div>
      </div>
    </div>

    <!-- Preview Panel (Right) -->
    <div class="preview-panel">
      <div class="preview-header">
        <div class="page-controls">
          <button id="prev-btn" disabled>&larr; Prev</button>
          <span id="page-info">Page 1 of 1</span>
          <button id="next-btn" disabled>Next &rarr;</button>
        </div>
        <select id="display-mode" title="Display mode">
          <option value="full">Full Chart</option>
          <option value="chords">Chords Only</option>
          <option value="lyrics">Lyrics Only</option>
        </select>
        <button class="download-btn" id="download-pdf-btn" title="Download PDF">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
          PDF
        </button>
        <button class="download-btn" id="download-fullset-btn" title="Download all keys as ZIP">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
          Full Set
        </button>
      </div>
      <div class="preview-container">
        <canvas id="chart-canvas"></canvas>
      </div>
    </div>
  </div>

  <script type="module">
    // Import from the compiled dist folder
    // Note: For this to work, you need to serve this from a local server
    // or use a bundler. For simplicity, we'll inline the necessary code.

    // Sample Song data structure (matches the parsed output)
    const SECTION_ABBREVIATIONS = {
      intro: 'I',
      verse: 'V',
      prechorus: 'Pr',
      halfchorus: 'HC',
      chorus: 'C',
      bridge: 'B',
      breakdown: 'Bd',
      outro: 'O',
      tag: 'Tg',
      instrumental: 'Inst',
      interlude: 'It',
      vamp: 'Vp',
      turnaround: 'T',
      ending: 'E',
      custom: ''
    };

    const SECTION_NAMES = {
      intro: 'INTRO',
      verse: 'VERSE',
      prechorus: 'PRE CHORUS',
      halfchorus: 'HALF-CHORUS',
      chorus: 'CHORUS',
      bridge: 'BRIDGE',
      breakdown: 'BREAKDOWN',
      outro: 'OUTRO',
      tag: 'TAG',
      instrumental: 'INSTRUMENTAL',
      interlude: 'INTERLUDE',
      vamp: 'VAMP',
      turnaround: 'TURNAROUND',
      ending: 'ENDING',
      custom: ''
    };

    // Default render configuration
    const DEFAULT_CONFIG = {
      displayMode: 'full', // 'full', 'chords', or 'lyrics'
      page: { width: 816, height: 1056 },
      margins: { top: 40, right: 40, bottom: 60, left: 40 },
      columnGap: 30,
      fonts: {
        title: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 28, weight: 'bold', lineHeight: 1.2 },
        artist: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 14, weight: 'normal', lineHeight: 1.4 },
        metadata: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 12, weight: 'normal', lineHeight: 1.4 },
        sectionName: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 13, weight: 'bold', lineHeight: 1.4 },
        chordRoot: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 14, weight: 'bold', lineHeight: 1.3 },
        chordQuality: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 10, weight: 'normal', lineHeight: 1.3 },
        lyrics: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 13, weight: 'normal', lineHeight: 1.4 },
        dynamics: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 11, weight: '300', lineHeight: 1.4 },
        roadmapBadge: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 10, weight: 'normal', lineHeight: 1 },
        pageNumber: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 12, weight: 'normal', lineHeight: 1.4 }
      },
      colors: {
        background: '#ffffff',
        text: '#000000',
        textSecondary: '#222222',
        textMuted: '#666666',
        badgeFill: '#4a4a4a',
        badgeText: '#ffffff',
        rule: '#cccccc',
        roadmapInactive: '#666666'
      },
      badgeRadius: 11,
      roadmapBadgeRadius: 12,
      spacing: {
        afterHeader: 15,
        afterRoadmap: 20,
        betweenSections: 18,
        betweenLines: 4,
        chordToLyric: 2,
        sectionHeaderHeight: 28,
        roadmapHeight: 36
      }
    };

    // Simple ChordPro parser for demo
    function parseChordPro(input) {
      const song = {
        title: 'Untitled',
        artist: 'Unknown',
        key: 'C',
        tempo: null,
        timeSignature: '4/4',
        sections: []
      };

      const lines = input.split(/\r?\n/);
      let currentSection = null;
      let pendingDynamics = null;

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        // Parse directives
        const directiveMatch = trimmed.match(/^\{(\w+):\s*(.+?)\}$/);
        if (directiveMatch) {
          const [, directive, value] = directiveMatch;
          switch (directive.toLowerCase()) {
            case 'title':
            case 't':
              song.title = value;
              break;
            case 'artist':
            case 'a':
              song.artist = value;
              break;
            case 'key':
            case 'k':
              song.key = value;
              break;
            case 'tempo':
              song.tempo = parseInt(value, 10);
              break;
            case 'time':
              song.timeSignature = value;
              break;
            case 'section':
              // Start new section
              const sectionInfo = parseSectionName(value);
              currentSection = {
                type: sectionInfo.type,
                number: sectionInfo.number,
                repeatCount: sectionInfo.repeatCount,
                hasVamp: sectionInfo.hasVamp,
                label: sectionInfo.label,
                dynamics: pendingDynamics,
                lines: []
              };
              pendingDynamics = null;
              song.sections.push(currentSection);
              break;
            case 'dynamics':
              if (currentSection) {
                if (currentSection.lines.length === 0) {
                  // Section header dynamics
                  currentSection.dynamics = value;
                } else {
                  // Mid-section dynamics - add as inline line
                  currentSection.lines.push({ type: 'dynamics', text: value });
                }
              } else {
                pendingDynamics = value;
              }
              break;
          }
          continue;
        }

        // Parse chord/lyric lines (preserve leading spaces for alignment)
        if (currentSection && trimmed.includes('[')) {
          const parsedLine = parseChordLine(line.trimEnd());
          currentSection.lines.push(parsedLine);
        } else if (currentSection && !trimmed.startsWith('{')) {
          // Plain lyrics without chords
          currentSection.lines.push({ lyrics: line.trimEnd(), chords: [] });
        }
      }

      return song;
    }

    function parseSectionName(value) {
      // Check for vamp indicator [Vamp] or [V]
      const vampMatch = value.match(/\s*\[(vamp|v)\]\s*$/i);
      const hasVamp = !!vampMatch;
      let valueWithoutModifier = value.replace(/\s*\[(vamp|v)\]\s*$/i, '').trim();

      // Check for repeat indicator [2x], [3x], etc.
      const repeatMatch = valueWithoutModifier.match(/\s*\[(\d+)x\]\s*$/i);
      const repeatCount = repeatMatch ? parseInt(repeatMatch[1], 10) : undefined;
      const valueWithoutRepeat = valueWithoutModifier.replace(/\s*\[\d+x\]\s*$/i, '').trim();

      // Check for numbered sections (Verse 1, Bridge 2, etc.)
      const numberMatch = valueWithoutRepeat.match(/(\d+)$/);
      const number = numberMatch ? parseInt(numberMatch[1], 10) : undefined;
      const baseName = valueWithoutRepeat.replace(/\s*\d+$/, '').toLowerCase().replace(/\s+/g, '');

      const typeMap = {
        'intro': 'intro',
        'verse': 'verse',
        'prechorus': 'prechorus',
        'pre-chorus': 'prechorus',
        'halfchorus': 'halfchorus',
        'half-chorus': 'halfchorus',
        'chorus': 'chorus',
        'bridge': 'bridge',
        'breakdown': 'breakdown',
        'outro': 'outro',
        'tag': 'tag',
        'instrumental': 'instrumental',
        'interlude': 'interlude',
        'vamp': 'vamp',
        'turnaround': 'turnaround',
        'ending': 'ending'
      };

      return {
        type: typeMap[baseName] || 'custom',
        number,
        repeatCount,
        hasVamp,
        label: typeMap[baseName] ? null : valueWithoutRepeat
      };
    }

    function parseChordLine(line) {
      const chords = [];
      let lyrics = '';
      let position = 0;
      let i = 0;

      while (i < line.length) {
        if (line[i] === '[') {
          const end = line.indexOf(']', i);
          if (end > i) {
            const chordStr = line.substring(i + 1, end);
            const chord = parseChordString(chordStr);
            chords.push({ chord, position });
            i = end + 1;
            continue;
          }
        }
        lyrics += line[i];
        position++;
        i++;
      }

      return { lyrics: lyrics.trimEnd() || undefined, chords };
    }

    function parseChordString(str) {
      // First check for number chords (Nashville notation): 1, 2, 42, 6m7, 1/3, etc.
      const numberMatch = str.match(/^([#b]?[1-7])(.*?)(?:\/([#b]?[1-7]))?$/);
      if (numberMatch) {
        const [, root, quality, bass] = numberMatch;
        return {
          root,
          quality: quality || undefined,
          bass: bass || undefined,
          isNumber: true
        };
      }

      // Match letter chords: root, quality, and optional bass note
      const match = str.match(/^([A-G][#b]?)(.*?)(?:\/([A-G][#b]?))?$/);
      if (!match) return { root: str };

      const [, root, quality, bass] = match;
      return {
        root,
        quality: quality || undefined,
        bass: bass || undefined,
        isNumber: false
      };
    }

    // Renderer implementation
    class ChartRenderer {
      constructor(config = DEFAULT_CONFIG) {
        this.config = config;
        this.song = null;
        this.layout = null;
        this.pixelRatio = window.devicePixelRatio || 1;
      }

      loadSong(song) {
        this.song = song;
        this.layout = this.calculateLayout();
      }

      calculateLayout() {
        if (!this.song) return null;

        const contentWidth = this.config.page.width - this.config.margins.left - this.config.margins.right;
        const columnWidth = (contentWidth - this.config.columnGap) / 2;

        const headerHeight =
          this.config.fonts.title.size * this.config.fonts.title.lineHeight +
          this.config.fonts.artist.size * this.config.fonts.artist.lineHeight +
          this.config.spacing.afterHeader;

        const roadmapHeight = this.config.spacing.roadmapHeight + this.config.spacing.afterRoadmap;
        const contentStartY = this.config.margins.top + headerHeight + roadmapHeight;
        const columnHeight = this.config.page.height - contentStartY - this.config.margins.bottom;

        const sections = [];
        let page = 0;
        let column = 0;
        let columnY = 0;

        const advanceColumn = () => {
          if (column === 0) {
            column = 1;
            columnY = 0;
          } else {
            page++;
            column = 0;
            columnY = 0;
          }
        };

        for (let i = 0; i < this.song.sections.length; i++) {
          const section = this.song.sections[i];
          const sectionHeight = this.calculateSectionHeight(section);

          // Skip sections with no content for this display mode
          if (sectionHeight === 0) {
            continue;
          }

          // If section doesn't fit and we're not at top, move to next column/page
          if (columnY > 0 && columnY + sectionHeight > columnHeight) {
            advanceColumn();
          }

          sections.push({
            sectionIndex: i,
            column,
            y: columnY,
            height: sectionHeight,
            page
          });

          columnY += sectionHeight + this.config.spacing.betweenSections;

          // If exceeded column height, next section goes to new column
          if (columnY >= columnHeight) {
            advanceColumn();
          }
        }

        return {
          pageCount: page + 1,
          sections,
          columnWidth,
          columnHeight,
          contentStartY,
          column1X: this.config.margins.left,
          column2X: this.config.margins.left + columnWidth + this.config.columnGap
        };
      }

      calculateSectionHeight(section) {
        const displayMode = this.config.displayMode || 'full';
        // Compact padding for chords-only mode
        const boxPadding = displayMode === 'chords'
          ? { top: 4, bottom: 6 }
          : { top: 8, bottom: 10 };

        // Always include sections - performers need to see structure
        // (e.g., vocalist needs to know there's an intro even with no lyrics)

        // Header (badge height)
        let height = this.config.badgeRadius * 2;

        // Box padding top
        height += boxPadding.top;

        // Dynamics
        if (section.dynamics) {
          height += this.config.fonts.dynamics.size * this.config.fonts.dynamics.lineHeight + 4;
        }

        // In chords-only mode, consolidate all chords into rows of 4
        if (displayMode === 'chords') {
          // Count total chords
          let totalChords = 0;
          for (const line of section.lines) {
            if (line.chords) {
              totalChords += line.chords.length;
            }
          }

          // Calculate number of rows (4 chords per row)
          const chordsPerRow = 4;
          const rowCount = Math.ceil(totalChords / chordsPerRow);

          // Add height for each row
          for (let i = 0; i < rowCount; i++) {
            if (i > 0) {
              height += 2; // Compact line spacing
            }
            height += this.config.fonts.chordRoot.size * this.config.fonts.chordRoot.lineHeight;
          }
        } else {
          // Full or lyrics mode - calculate line by line
          let lineCount = 0;
          for (let i = 0; i < section.lines.length; i++) {
            const line = section.lines[i];

            // Handle dynamics lines
            if (line.type === 'dynamics') {
              if (lineCount > 0) {
                height += this.config.spacing.betweenLines;
              }
              lineCount++;
              height += this.config.fonts.dynamics.size * this.config.fonts.dynamics.lineHeight;
              continue;
            }

            const hasChords = line.chords && line.chords.length > 0;
            const hasLyrics = line.lyrics && line.lyrics.trim().length > 0;

            // Skip lines based on display mode
            if (displayMode === 'lyrics' && !hasLyrics) continue;

            // Add spacing between lines
            if (lineCount > 0) {
              height += this.config.spacing.betweenLines;
            }
            lineCount++;

            // Calculate line height based on display mode
            if (displayMode === 'lyrics') {
              // Always include chord space for visual consistency
              height += this.config.fonts.chordRoot.size * this.config.fonts.chordRoot.lineHeight;
              height += this.config.spacing.chordToLyric;
              height += this.config.fonts.lyrics.size * this.config.fonts.lyrics.lineHeight;
            } else {
              // Full mode
              const isChordOnly = hasChords && !hasLyrics;
              if (isChordOnly) {
                height += this.config.fonts.chordRoot.size * this.config.fonts.chordRoot.lineHeight;
              } else if (hasChords && hasLyrics) {
                height += this.config.fonts.chordRoot.size * this.config.fonts.chordRoot.lineHeight;
                height += this.config.spacing.chordToLyric;
                height += this.config.fonts.lyrics.size * this.config.fonts.lyrics.lineHeight;
              } else if (hasLyrics) {
                // Lyrics-only line: include chord space for visual consistency
                height += this.config.fonts.chordRoot.size * this.config.fonts.chordRoot.lineHeight;
                height += this.config.spacing.chordToLyric;
                height += this.config.fonts.lyrics.size * this.config.fonts.lyrics.lineHeight;
              }
            }
          }
        }

        // Box padding bottom
        height += boxPadding.bottom;

        return height;
      }

      renderPage(canvas, pageIndex) {
        if (!this.song || !this.layout) return;

        const { width, height } = this.config.page;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        canvas.width = width * this.pixelRatio;
        canvas.height = height * this.pixelRatio;

        const ctx = canvas.getContext('2d');
        ctx.scale(this.pixelRatio, this.pixelRatio);

        // Clear background
        ctx.fillStyle = this.config.colors.background;
        ctx.fillRect(0, 0, width, height);

        // Render header
        let y = this.renderHeader(ctx, pageIndex);

        // Render roadmap (first page only)
        if (pageIndex === 0) {
          y = this.renderRoadmap(ctx, y);
          y += this.config.spacing.afterRoadmap;
        }

        // Render sections
        // Use actual y from header/roadmap for this page, not the fixed contentStartY
        const pageContentStartY = y;
        const pageSections = this.layout.sections.filter(s => s.page === pageIndex);

        for (const layoutSection of pageSections) {
          const section = this.song.sections[layoutSection.sectionIndex];
          const x = layoutSection.column === 0 ? this.layout.column1X : this.layout.column2X;
          const sectionY = pageContentStartY + layoutSection.y;

          this.renderSection(ctx, section, x, sectionY, this.layout.columnWidth);
        }

        // Footer on first page only
        if (pageIndex === 0) {
          const config = this.config;
          ctx.font = `300 ${config.fonts.metadata.size - 2}px ${config.fonts.metadata.family}`;
          ctx.fillStyle = config.colors.textMuted;
          ctx.textAlign = 'right';
          ctx.textBaseline = 'bottom';
          ctx.fillText('charted by proflee.me', config.page.width - config.margins.right, config.page.height - 12);
        }
      }

      renderHeader(ctx, pageIndex) {
        const config = this.config;
        let y = config.margins.top;

        if (pageIndex === 0) {
          // Title
          ctx.font = `${config.fonts.title.weight} ${config.fonts.title.size}px ${config.fonts.title.family}`;
          ctx.fillStyle = config.colors.text;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(this.song.title, config.margins.left, y);

          // Page number
          ctx.font = `${config.fonts.pageNumber.weight} ${config.fonts.pageNumber.size}px ${config.fonts.pageNumber.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'right';
          ctx.fillText(`Page: ${pageIndex + 1}/${this.layout.pageCount}`, config.page.width - config.margins.right, y);

          y += config.fonts.title.size * config.fonts.title.lineHeight;

          // Artist
          ctx.font = `${config.fonts.artist.weight} ${config.fonts.artist.size}px ${config.fonts.artist.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'left';
          ctx.fillText(this.song.artist, config.margins.left, y);

          // Metadata
          ctx.font = `${config.fonts.metadata.weight} ${config.fonts.metadata.size}px ${config.fonts.metadata.family}`;
          ctx.textAlign = 'right';
          const meta = [];
          if (this.song.key) {
            const keyLabel = this.config.numbersMode ? 'Original Key' : 'Key';
            meta.push(`${keyLabel}: ${this.song.key.replace(/b/g, '♭').replace(/#/g, '♯')}`);
          }
          if (this.song.tempo) meta.push(`Tempo: ${this.song.tempo}`);
          if (this.song.timeSignature) meta.push(`Meter: ${this.song.timeSignature}`);
          ctx.fillText(meta.join('  '), config.page.width - config.margins.right, y);

          y += config.fonts.artist.size * config.fonts.artist.lineHeight;
        } else {
          // Compact header
          ctx.font = `bold ${config.fonts.sectionName.size + 4}px ${config.fonts.title.family}`;
          ctx.fillStyle = config.colors.text;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(this.song.title, config.margins.left, y);

          ctx.font = `${config.fonts.pageNumber.weight} ${config.fonts.pageNumber.size}px ${config.fonts.pageNumber.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'right';
          ctx.fillText(`Page: ${pageIndex + 1}/${this.layout.pageCount}`, config.page.width - config.margins.right, y);

          y += (config.fonts.sectionName.size + 4) * 1.4;
        }

        return y + config.spacing.afterHeader;
      }

      renderRoadmap(ctx, y) {
        const config = this.config;
        const entries = this.generateRoadmap();
        let x = config.margins.left;

        for (const entry of entries) {
          const radius = config.roadmapBadgeRadius;
          const centerY = y + radius;

          // Draw circle (outline for roadmap)
          ctx.beginPath();
          ctx.arc(x + radius, centerY, radius, 0, Math.PI * 2);
          ctx.strokeStyle = config.colors.roadmapInactive;
          ctx.lineWidth = 1.5;
          ctx.stroke();

          // Draw abbreviation
          ctx.font = `${config.fonts.roadmapBadge.weight} ${config.fonts.roadmapBadge.size}px ${config.fonts.roadmapBadge.family}`;
          ctx.fillStyle = config.colors.roadmapInactive;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(entry.abbreviation, x + radius, centerY);

          // Superscript for repeat count or vamp - at top-right of circle
          if (entry.repeatCount > 1 || entry.hasVamp) {
            const superSize = config.fonts.roadmapBadge.size * 0.7;
            ctx.font = `${superSize}px ${config.fonts.roadmapBadge.family}`;

            // Build superscript text
            let superText = '';
            if (entry.repeatCount > 1) superText += entry.repeatCount.toString();
            if (entry.hasVamp) superText += 'v';

            // Position: top-right, overlapping circle edge
            const superX = x + radius + radius * 0.5;
            const superY = y + radius * 0.5;

            // Measure text for background
            const textMetrics = ctx.measureText(superText);
            const padding = 2;
            const bgX = superX - padding;
            const bgY = superY - superSize - padding;
            const bgWidth = textMetrics.width + padding * 2;
            const bgHeight = superSize + padding * 2;

            // Draw background to erase circle line
            ctx.fillStyle = config.colors.background;
            ctx.fillRect(bgX, bgY, bgWidth, bgHeight);

            // Draw superscript text
            ctx.fillStyle = config.colors.text;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            ctx.fillText(superText, superX, superY);
          }

          x += radius * 2 + 10;
        }

        return y + config.spacing.roadmapHeight;
      }

      generateRoadmap() {
        const entries = [];
        let currentAbbr = '';
        let currentCount = 0;
        let currentExplicitRepeat = null;
        let currentHasVamp = false;

        for (const section of this.song.sections) {
          let abbr = SECTION_ABBREVIATIONS[section.type] || '';
          if (section.number) abbr += section.number;
          if (section.type === 'custom' && section.label) {
            abbr = section.label.substring(0, 2).toUpperCase();
          }

          // If section has explicit repeat count or vamp, use that
          const explicitRepeat = section.repeatCount || null;
          const hasVamp = section.hasVamp || false;

          if (abbr === currentAbbr && !explicitRepeat && !currentExplicitRepeat && !hasVamp && !currentHasVamp) {
            // Consecutive same section without explicit repeats or vamp
            currentCount++;
          } else {
            if (currentAbbr) {
              const repeatCount = currentExplicitRepeat || (currentCount > 1 ? currentCount : null);
              entries.push({ abbreviation: currentAbbr, repeatCount, hasVamp: currentHasVamp });
            }
            currentAbbr = abbr;
            currentCount = 1;
            currentExplicitRepeat = explicitRepeat;
            currentHasVamp = hasVamp;
          }
        }

        if (currentAbbr) {
          const repeatCount = currentExplicitRepeat || (currentCount > 1 ? currentCount : null);
          entries.push({ abbreviation: currentAbbr, repeatCount, hasVamp: currentHasVamp });
        }

        return entries;
      }

      renderSection(ctx, section, x, y, width) {
        const config = this.config;
        const boxPadding = { top: 8, right: 8, bottom: 10, left: 8 };
        const cornerRadius = 8;

        // Render badge
        const abbr = this.getSectionAbbreviation(section);
        const badgeRadius = config.badgeRadius;
        const badgeOffset = cornerRadius + 8; // Left margin: after top-left corner + padding

        ctx.beginPath();
        ctx.arc(x + badgeOffset + badgeRadius, y + badgeRadius, badgeRadius, 0, Math.PI * 2);
        ctx.fillStyle = config.colors.badgeFill;
        ctx.fill();

        ctx.font = `${config.fonts.roadmapBadge.weight} ${config.fonts.roadmapBadge.size}px ${config.fonts.roadmapBadge.family}`;
        ctx.fillStyle = config.colors.badgeText;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(abbr, x + badgeOffset + badgeRadius, y + badgeRadius);

        // Render section name
        const displayName = this.getSectionDisplayName(section);
        const nameX = x + badgeOffset + badgeRadius * 2 + 8;
        const nameY = y + badgeRadius;

        ctx.font = `${config.fonts.sectionName.weight} ${config.fonts.sectionName.size}px ${config.fonts.sectionName.family}`;
        ctx.fillStyle = config.colors.text;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(displayName, nameX, nameY);

        const nameWidth = ctx.measureText(displayName).width;
        const ruleStartX = nameX + nameWidth + 10;

        // Content area starts below header
        let currentY = y + badgeRadius * 2 + boxPadding.top;

        // Dynamics (right-aligned, below header)
        if (section.dynamics) {
          ctx.font = `${config.fonts.dynamics.weight} ${config.fonts.dynamics.size}px ${config.fonts.dynamics.family}`;
          ctx.fillStyle = config.colors.textMuted;
          ctx.textAlign = 'right';
          ctx.textBaseline = 'top';
          ctx.fillText(section.dynamics, x + width - boxPadding.right, currentY);
          currentY += config.fonts.dynamics.size * config.fonts.dynamics.lineHeight + 4;
        }

        // Render lines with left padding
        const contentX = x + boxPadding.left;
        const contentWidth = width - boxPadding.left - boxPadding.right;
        const displayMode = config.displayMode || 'full';

        // In chords-only mode, consolidate chords into rows of 4
        if (displayMode === 'chords') {
          // Collect all chords from all lines
          const allChords = [];
          for (const line of section.lines) {
            if (line.chords && line.chords.length > 0) {
              for (const cp of line.chords) {
                allChords.push(cp.chord);
              }
            }
          }

          // Group into rows of 4 chords
          const chordsPerRow = 4;
          let renderedRowCount = 0;
          for (let i = 0; i < allChords.length; i += chordsPerRow) {
            const rowChords = allChords.slice(i, i + chordsPerRow);

            if (renderedRowCount > 0) {
              currentY += 2; // Compact line spacing
            }

            const chordY = currentY + config.fonts.chordRoot.size;
            this.renderChordRow(ctx, rowChords, contentX, chordY, contentWidth);
            currentY += config.fonts.chordRoot.size * config.fonts.chordRoot.lineHeight;
            renderedRowCount++;
          }
        } else {
          // Full or lyrics mode - render line by line
          let renderedLineCount = 0;
          for (let i = 0; i < section.lines.length; i++) {
            const line = section.lines[i];
            const hasChords = line.chords && line.chords.length > 0;
            const hasLyrics = line.lyrics && line.lyrics.trim().length > 0;

            // Skip lines based on display mode
            if (displayMode === 'lyrics' && !hasLyrics) continue;

            // Add spacing between lines (before the line, not after)
            if (renderedLineCount > 0) {
              currentY += config.spacing.betweenLines;
            }

            currentY += this.renderLine(ctx, line, contentX, currentY, contentWidth);
            renderedLineCount++;
          }
        }

        // Add bottom padding
        currentY += boxPadding.bottom;

        // Draw section box with rounded corners
        const boxTop = nameY;
        const boxBottom = currentY;
        const topLeftEnd = x + cornerRadius + 4; // Where top-left corner ends

        ctx.strokeStyle = config.colors.rule;
        ctx.lineWidth = 1;

        // Main box path: top-left corner -> left -> bottom-left -> bottom -> bottom-right -> right -> top-right corner
        ctx.beginPath();

        // Top-left rounded corner
        ctx.moveTo(topLeftEnd, boxTop);
        ctx.quadraticCurveTo(x, boxTop, x, boxTop + cornerRadius);

        // Left side down to bottom
        ctx.lineTo(x, boxBottom - cornerRadius);

        // Bottom-left rounded corner
        ctx.quadraticCurveTo(x, boxBottom, x + cornerRadius, boxBottom);

        // Bottom line
        ctx.lineTo(x + width - cornerRadius, boxBottom);

        // Bottom-right rounded corner
        ctx.quadraticCurveTo(x + width, boxBottom, x + width, boxBottom - cornerRadius);

        // Right side up to top
        ctx.lineTo(x + width, boxTop + cornerRadius);

        // Top-right rounded corner
        ctx.quadraticCurveTo(x + width, boxTop, x + width - cornerRadius, boxTop);

        // Top rule from top-right corner to after section name
        ctx.lineTo(ruleStartX, boxTop);

        ctx.stroke();

        return currentY - y;
      }

      renderLine(ctx, line, x, y, width) {
        const config = this.config;
        const displayMode = config.displayMode || 'full';
        let currentY = y;

        // Handle dynamics lines (mid-section dynamics)
        if (line.type === 'dynamics') {
          ctx.font = `${config.fonts.dynamics.weight} ${config.fonts.dynamics.size}px ${config.fonts.dynamics.family}`;
          ctx.fillStyle = config.colors.textMuted;
          ctx.textAlign = 'right';
          ctx.textBaseline = 'top';
          ctx.fillText(line.text, x + width, currentY);
          currentY += config.fonts.dynamics.size * config.fonts.dynamics.lineHeight;
          return currentY - y;
        }

        const hasChords = line.chords && line.chords.length > 0;
        const hasLyrics = line.lyrics && line.lyrics.trim().length > 0;

        // Skip lines based on display mode
        if (displayMode === 'chords' && !hasChords) return 0;
        if (displayMode === 'lyrics' && !hasLyrics) return 0;

        // Chords-only mode: render only chords
        if (displayMode === 'chords') {
          const chordY = currentY + config.fonts.chordRoot.size;
          this.renderChordRow(ctx, line.chords.map(c => c.chord), x, chordY, width);
          currentY += config.fonts.chordRoot.size * config.fonts.chordRoot.lineHeight;
          return currentY - y;
        }

        // Lyrics-only mode: render lyrics with chord space for visual consistency
        if (displayMode === 'lyrics') {
          // Skip chord row space (keep spacing consistent)
          currentY += config.fonts.chordRoot.size * config.fonts.chordRoot.lineHeight;
          currentY += config.spacing.chordToLyric;
          // Render lyrics
          ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(line.lyrics, x, currentY);
          currentY += config.fonts.lyrics.size * config.fonts.lyrics.lineHeight;
          return currentY - y;
        }

        // Full mode: render both
        const isChordOnly = hasChords && !hasLyrics;

        if (isChordOnly) {
          // Chord-only line
          const chordY = currentY + config.fonts.chordRoot.size;
          this.renderChordRow(ctx, line.chords.map(c => c.chord), x, chordY, width);
          currentY += config.fonts.chordRoot.size * config.fonts.chordRoot.lineHeight;

        } else if (hasChords && hasLyrics) {
          // Chords above lyrics - renders both with stretched spacing
          const chordY = currentY + config.fonts.chordRoot.size;
          currentY += config.fonts.chordRoot.size * config.fonts.chordRoot.lineHeight;
          currentY += config.spacing.chordToLyric;
          const lyricY = currentY;

          this.renderChordsAboveLyrics(ctx, line.chords, line.lyrics, x, chordY, lyricY);
          currentY += config.fonts.lyrics.size * config.fonts.lyrics.lineHeight;

        } else if (hasLyrics) {
          // Lyrics-only line: include chord space for visual consistency
          currentY += config.fonts.chordRoot.size * config.fonts.chordRoot.lineHeight;
          currentY += config.spacing.chordToLyric;
          ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(line.lyrics, x, currentY);
          currentY += config.fonts.lyrics.size * config.fonts.lyrics.lineHeight;
        }

        return currentY - y;
      }

      // Convert accidentals to Unicode symbols for display
      formatAccidentals(str) {
        return str.replace(/b/g, '♭').replace(/#/g, '♯');
      }

      renderChord(ctx, chord, x, y) {
        const config = this.config;
        let currentX = x;

        const displayRoot = this.formatAccidentals(chord.root);
        ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
        ctx.fillStyle = config.colors.text;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(displayRoot, currentX, y);
        currentX += ctx.measureText(displayRoot).width;

        if (chord.quality) {
          const displayQuality = this.formatAccidentals(chord.quality);
          ctx.font = `${config.fonts.chordQuality.weight} ${config.fonts.chordQuality.size}px ${config.fonts.chordQuality.family}`;
          const qualityY = y - (config.fonts.chordRoot.size * 0.25);
          ctx.fillText(displayQuality, currentX, qualityY);
          currentX += ctx.measureText(displayQuality).width;
        }

        if (chord.bass) {
          const displayBass = '/' + this.formatAccidentals(chord.bass);
          ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
          ctx.fillText(displayBass, currentX, y);
          currentX += ctx.measureText(displayBass).width;
        }

        return currentX - x;
      }

      measureChordWidth(ctx, chord) {
        const config = this.config;
        let width = 0;

        const displayRoot = this.formatAccidentals(chord.root);
        ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
        width += ctx.measureText(displayRoot).width;

        if (chord.quality) {
          const displayQuality = this.formatAccidentals(chord.quality);
          ctx.font = `${config.fonts.chordQuality.weight} ${config.fonts.chordQuality.size}px ${config.fonts.chordQuality.family}`;
          width += ctx.measureText(displayQuality).width;
        }

        if (chord.bass) {
          const displayBass = '/' + this.formatAccidentals(chord.bass);
          ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
          width += ctx.measureText(displayBass).width;
        }

        return width;
      }

      renderChordRow(ctx, chords, x, y, width) {
        if (chords.length === 0) return;
        if (chords.length === 1) {
          this.renderChord(ctx, chords[0], x, y);
          return;
        }

        const chordWidths = chords.map(c => this.measureChordWidth(ctx, c));
        const totalWidth = chordWidths.reduce((a, b) => a + b, 0);

        // In chords-only mode, use compact fixed spacing
        // In full mode, distribute evenly across width
        const displayMode = this.config.displayMode || 'full';
        const compactSpacing = 24; // Fixed spacing between chords in chords-only mode
        const spacing = displayMode === 'chords'
          ? compactSpacing
          : (width - totalWidth) / chords.length;

        let currentX = x;
        for (let i = 0; i < chords.length; i++) {
          this.renderChord(ctx, chords[i], currentX, y);
          currentX += chordWidths[i] + spacing;
        }
      }

      renderChordsAboveLyrics(ctx, chordPositions, lyrics, x, chordY, lyricY) {
        const config = this.config;

        // Sort by position
        const sorted = [...chordPositions].sort((a, b) => a.position - b.position);

        ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;

        const minGap = 8;
        const positions = [];
        const segments = [];
        let currentX = x;

        // Calculate positions with overlap prevention
        for (let i = 0; i < sorted.length; i++) {
          const cp = sorted[i];
          const prevPos = i === 0 ? 0 : sorted[i - 1].position;
          const segmentText = lyrics.substring(prevPos, cp.position);

          if (segmentText) {
            ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;
            segments.push({ text: segmentText, xPos: currentX });
            currentX += ctx.measureText(segmentText).width;
          }

          const chordWidth = this.measureChordWidth(ctx, cp.chord);

          // Check overlap with previous chord
          if (positions.length > 0) {
            const prev = positions[positions.length - 1];
            const minX = prev.xPos + prev.width + minGap;
            if (currentX < minX) {
              currentX = minX;
            }
          }

          positions.push({ chord: cp.chord, xPos: currentX, width: chordWidth });
        }

        // Add remaining lyrics
        if (sorted.length > 0) {
          const lastPos = sorted[sorted.length - 1].position;
          const remaining = lyrics.substring(lastPos);
          if (remaining) {
            segments.push({ text: remaining, xPos: currentX });
          }
        }

        // Render chords
        for (const p of positions) {
          this.renderChord(ctx, p.chord, p.xPos, chordY);
        }

        // Render stretched lyrics
        ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;
        ctx.fillStyle = config.colors.textSecondary;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';

        for (const seg of segments) {
          ctx.fillText(seg.text, seg.xPos, lyricY);
        }
      }

      getSectionAbbreviation(section) {
        let abbr = SECTION_ABBREVIATIONS[section.type] || '';
        if (section.number) abbr += section.number;
        if (section.type === 'custom' && section.label) {
          abbr = section.label.substring(0, 2).toUpperCase();
        }
        return abbr;
      }

      getSectionDisplayName(section) {
        let name;
        if (section.label) {
          name = section.label.toUpperCase();
        } else {
          name = SECTION_NAMES[section.type] || section.type.toUpperCase();
          if (section.number) name += ' ' + section.number;
        }
        // Add repeat/vamp indicators
        if (section.repeatCount > 1) name += ` [${section.repeatCount}x]`;
        if (section.hasVamp) name += ' [Vamp]';
        return name;
      }
    }

    // Demo app
    const inputEl = document.getElementById('input');
    const backdropEl = document.getElementById('backdrop');
    const highlightEl = document.getElementById('highlight');
    const canvas = document.getElementById('chart-canvas');
    const errorEl = document.getElementById('error');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const pageInfoEl = document.getElementById('page-info');

    let renderer = new ChartRenderer();
    let currentPage = 0;

    // Syntax highlighting for the editor
    function highlightSyntax(text) {
      // Escape HTML
      let html = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      // Highlight directives: {key: value}
      html = html.replace(
        /(\{)(title|artist|key|tempo|time)(:)([^}]*)(\})/gi,
        '<span class="hl-brace">$1</span><span class="hl-directive-key">$2</span><span class="hl-brace">$3</span><span class="hl-directive-value">$4</span><span class="hl-brace">$5</span>'
      );

      // Highlight sections: {section: Name}
      html = html.replace(
        /(\{)(section)(:)([^}]*)(\})/gi,
        '<span class="hl-brace">$1</span><span class="hl-section">$2</span><span class="hl-brace">$3</span><span class="hl-section-name">$4</span><span class="hl-brace">$5</span>'
      );

      // Highlight dynamics: {dynamics: value}
      html = html.replace(
        /(\{)(dynamics)(:)([^}]*)(\})/gi,
        '<span class="hl-brace">$1</span><span class="hl-directive-key">$2</span><span class="hl-brace">$3</span><span class="hl-directive-value">$4</span><span class="hl-brace">$5</span>'
      );

      // Highlight chords: [chord]
      html = html.replace(
        /(\[)([^\]]+)(\])/g,
        '<span class="hl-bracket">$1</span><span class="hl-chord">$2</span><span class="hl-bracket">$3</span>'
      );

      return html;
    }

    function syncHighlight() {
      highlightEl.innerHTML = highlightSyntax(inputEl.value) + '\n';
    }

    // Sync scroll between textarea and backdrop
    inputEl.addEventListener('scroll', () => {
      backdropEl.scrollTop = inputEl.scrollTop;
      backdropEl.scrollLeft = inputEl.scrollLeft;
    });

    function updatePageControls() {
      const pageCount = renderer.layout ? renderer.layout.pageCount : 1;
      pageInfoEl.textContent = `Page ${currentPage + 1} of ${pageCount}`;
      prevBtn.disabled = currentPage === 0;
      nextBtn.disabled = currentPage >= pageCount - 1;
    }

    function render() {
      try {
        errorEl.style.display = 'none';
        const input = inputEl.value;
        const song = parseChordPro(input);
        renderer.loadSong(song);
        // Preserve current page, but clamp to valid range if page count changed
        const maxPage = renderer.layout ? renderer.layout.pageCount - 1 : 0;
        if (currentPage > maxPage) currentPage = maxPage;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      } catch (e) {
        errorEl.textContent = 'Error: ' + e.message;
        errorEl.style.display = 'block';
        console.error(e);
      }
    }

    // Realtime rendering and highlighting on textarea input
    inputEl.addEventListener('input', () => {
      syncHighlight();
      render();
    });

    // Auto-complete: numbers wrap in [], { completes to {}
    inputEl.addEventListener('keydown', (e) => {
      const start = inputEl.selectionStart;
      const end = inputEl.selectionEnd;
      const value = inputEl.value;

      // Auto-wrap numbers in brackets
      if (e.key >= '0' && e.key <= '9') {
        // Check if already inside brackets or braces
        const beforeCursor = value.substring(0, start);
        const lastOpen = beforeCursor.lastIndexOf('[');
        const lastClose = beforeCursor.lastIndexOf(']');
        const insideBrackets = lastOpen > lastClose;
        const lastBraceOpen = beforeCursor.lastIndexOf('{');
        const lastBraceClose = beforeCursor.lastIndexOf('}');
        const insideBraces = lastBraceOpen > lastBraceClose;

        if (!insideBrackets && !insideBraces) {
          e.preventDefault();
          const newValue = value.substring(0, start) + '[' + e.key + ']' + value.substring(end);
          inputEl.value = newValue;
          inputEl.selectionStart = inputEl.selectionEnd = start + 2; // After the number, before ]
          syncHighlight();
          render();
        }
      }

      // Auto-complete { to {}
      if (e.key === '{') {
        e.preventDefault();
        const newValue = value.substring(0, start) + '{}' + value.substring(end);
        inputEl.value = newValue;
        inputEl.selectionStart = inputEl.selectionEnd = start + 1; // Between { and }
        syncHighlight();
        render();
      }
    });

    prevBtn.addEventListener('click', () => {
      if (currentPage > 0) {
        currentPage--;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      }
    });

    nextBtn.addEventListener('click', () => {
      if (renderer.layout && currentPage < renderer.layout.pageCount - 1) {
        currentPage++;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      }
    });

    // Library search functionality
    let libraryIndex = [];
    const songSearchEl = document.getElementById('song-search');
    const searchResultsEl = document.getElementById('search-results');
    const randomBtn = document.getElementById('random-btn');
    let selectedResultIndex = -1;

    // Load library index
    async function loadLibraryIndex() {
      try {
        const response = await fetch('library/index.json');
        libraryIndex = await response.json();
        songSearchEl.placeholder = `Search ${libraryIndex.length} songs...`;
      } catch (e) {
        console.error('Failed to load library index:', e);
        songSearchEl.placeholder = 'Library unavailable';
      }
    }

    // Track currently loaded song
    let currentSongPath = null;

    // Fetch song content
    async function loadSong(path) {
      try {
        const response = await fetch(`library/${path}`);
        const content = await response.text();
        inputEl.value = content;
        currentSongPath = path;
        syncHighlight();
        render();
        songSearchEl.value = '';
        hideSearchResults();
        updateButtonStates();
      } catch (e) {
        console.error('Failed to load song:', e);
        errorEl.textContent = 'Error loading song: ' + e.message;
        errorEl.style.display = 'block';
      }
    }

    // Update button states based on current song
    function updateButtonStates() {
      const updateBtn = document.getElementById('update-btn');
      const deleteBtn = document.getElementById('delete-btn');
      deleteBtn.disabled = !currentSongPath;
      // Update button always enabled, but changes label
      updateBtn.textContent = currentSongPath ? 'Update' : 'Save';
    }

    // Extract title from chart content
    function extractTitle(content) {
      const match = content.match(/\{title:\s*(.+?)\}/i);
      return match ? match[1].trim() : 'Untitled';
    }

    // Library management functions
    async function createNewSong() {
      const template = `{title: New Song}
{artist: Artist Name}
{key: C}
{tempo: 120}
{time: 4/4}

{section: Verse 1}
[1] [4] [5] [1]

{section: Chorus}
[1] [5] [6m] [4]
`;
      inputEl.value = template;
      currentSongPath = null;
      syncHighlight();
      render();
      updateButtonStates();
    }

    async function updateSong() {
      if (!currentSongPath) {
        alert('No song loaded from library. Use "New" to create a new song first.');
        return;
      }

      const content = inputEl.value;
      try {
        const response = await fetch(`/api/library/${encodeURIComponent(currentSongPath)}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'text/plain' },
          body: content
        });

        if (response.ok) {
          alert('Song updated successfully!');
          // Refresh library index
          await loadLibraryIndex();
        } else {
          throw new Error(await response.text());
        }
      } catch (e) {
        // Fallback: offer download
        console.error('API not available, using download fallback:', e);
        downloadSong(content, currentSongPath);
      }
    }

    async function saveSongAsNew() {
      const content = inputEl.value;
      const title = extractTitle(content);
      const filename = title.replace(/[^a-zA-Z0-9\s]/g, '').trim() + '.txt';

      try {
        const response = await fetch(`/api/library/${encodeURIComponent(filename)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain' },
          body: content
        });

        if (response.ok) {
          currentSongPath = filename;
          alert('Song saved to library!');
          await loadLibraryIndex();
          updateButtonStates();
        } else {
          throw new Error(await response.text());
        }
      } catch (e) {
        // Fallback: offer download
        console.error('API not available, using download fallback:', e);
        downloadSong(content, filename);
      }
    }

    async function deleteSong() {
      if (!currentSongPath) {
        alert('No song loaded from library.');
        return;
      }

      const title = extractTitle(inputEl.value);
      if (!confirm(`Move "${title}" to trash?`)) {
        return;
      }

      try {
        const response = await fetch(`/api/library/${encodeURIComponent(currentSongPath)}`, {
          method: 'DELETE'
        });

        if (response.ok) {
          alert('Song moved to trash.');
          currentSongPath = null;
          createNewSong();
          await loadLibraryIndex();
        } else {
          throw new Error(await response.text());
        }
      } catch (e) {
        console.error('API not available:', e);
        alert('Delete requires the API server. Run: node demo/server.js');
      }
    }

    function downloadSong(content, filename) {
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      alert(`Downloaded "${filename}". Move it to the library folder manually.`);
    }

    // Library management button handlers
    document.getElementById('new-btn').addEventListener('click', () => {
      if (currentSongPath || inputEl.value.trim()) {
        if (!confirm('Create new song? Unsaved changes will be lost.')) return;
      }
      createNewSong();
    });

    document.getElementById('update-btn').addEventListener('click', () => {
      if (currentSongPath) {
        updateSong();
      } else {
        saveSongAsNew();
      }
    });

    document.getElementById('delete-btn').addEventListener('click', deleteSong);

    // PDF download
    document.getElementById('download-pdf-btn').addEventListener('click', async () => {
      if (!renderer.layout) return;

      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'pt',
        format: [renderer.config.page.width, renderer.config.page.height]
      });

      const title = extractTitle(inputEl.value);
      const pageCount = renderer.layout.pageCount;

      // Create high-res canvas for PDF export (3x for print quality)
      const exportScale = 3;
      const exportCanvas = document.createElement('canvas');
      const { width, height } = renderer.config.page;
      exportCanvas.width = width * exportScale;
      exportCanvas.height = height * exportScale;

      // Temporarily override pixel ratio for high-res rendering
      const originalRatio = renderer.pixelRatio;
      renderer.pixelRatio = exportScale;

      for (let i = 0; i < pageCount; i++) {
        if (i > 0) pdf.addPage();

        // Render page to high-res canvas
        renderer.renderPage(exportCanvas, i);

        // Add canvas as image to PDF (JPEG for smaller file size)
        const imgData = exportCanvas.toDataURL('image/jpeg', 0.92);
        pdf.addImage(imgData, 'JPEG', 0, 0, width, height);
      }

      // Restore original pixel ratio and redraw preview
      renderer.pixelRatio = originalRatio;
      renderer.renderPage(canvas, currentPage);

      // Download with key and mode in filename
      const safeTitle = title.replace(/[^a-zA-Z0-9\s]/g, '').trim();
      const mode = displayModeSelect.value;
      const keyLabel = renderKeySelect.value === 'numbers' ? 'Numbers' : renderKeySelect.value;
      // Lyrics don't change with key, so omit key from filename
      const filename = mode === 'lyrics'
        ? `${safeTitle} - Lyrics.pdf`
        : `${safeTitle} - ${keyLabel}${mode === 'chords' ? ' - Chords' : ''}.pdf`;
      pdf.save(filename);
    });

    // Full Set download (all keys, full and chords modes as ZIP)
    const ALL_KEYS = ['numbers', 'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const ALL_MODES = [
      { value: 'full', label: '' },        // Full chart (no suffix)
      { value: 'chords', label: 'Chords' }  // Chords only
    ];

    document.getElementById('download-fullset-btn').addEventListener('click', async () => {
      const input = inputEl.value;
      const baseSong = parseChordPro(input);
      const title = baseSong.title || 'Untitled';
      const safeTitle = title.replace(/[^a-zA-Z0-9\s]/g, '').trim();

      const { jsPDF } = window.jspdf;
      const zip = new JSZip();

      const btn = document.getElementById('download-fullset-btn');
      const originalText = btn.innerHTML;
      btn.disabled = true;

      // Create high-res canvas for PDF export (3x for print quality)
      const exportScale = 3;
      const exportCanvas = document.createElement('canvas');
      const { width, height } = renderer.config.page;
      exportCanvas.width = width * exportScale;
      exportCanvas.height = height * exportScale;

      // Save and override pixel ratio for high-res rendering
      const originalRatio = renderer.pixelRatio;
      renderer.pixelRatio = exportScale;

      const totalFiles = ALL_KEYS.length * ALL_MODES.length;
      let fileCount = 0;

      for (let k = 0; k < ALL_KEYS.length; k++) {
        const key = ALL_KEYS[k];

        // Convert song to this key
        let song;
        if (key === 'numbers') {
          song = baseSong;
        } else {
          song = convertSongToLetters(baseSong, key);
          song.key = key;
        }

        // Generate PDF for each display mode
        for (const mode of ALL_MODES) {
          fileCount++;
          btn.textContent = `${fileCount}/${totalFiles}...`;

          // Set display mode and load song
          renderer.config.displayMode = mode.value;
          renderer.loadSong(song);
          const pageCount = renderer.layout.pageCount;

          const pdf = new jsPDF({
            orientation: 'portrait',
            unit: 'pt',
            format: [width, height]
          });

          for (let i = 0; i < pageCount; i++) {
            if (i > 0) pdf.addPage();
            renderer.renderPage(exportCanvas, i);
            const imgData = exportCanvas.toDataURL('image/jpeg', 0.92);
            pdf.addImage(imgData, 'JPEG', 0, 0, width, height);
          }

          const keyLabel = key === 'numbers' ? 'Numbers' : key;
          const modeLabel = mode.label ? ` - ${mode.label}` : '';
          const pdfFilename = `${safeTitle} - ${keyLabel}${modeLabel}.pdf`;
          zip.file(pdfFilename, pdf.output('blob'));

          // Allow UI to update
          await new Promise(r => setTimeout(r, 10));
        }
      }

      // Restore original pixel ratio
      renderer.pixelRatio = originalRatio;

      // Restore original view
      render();

      // Generate and download ZIP
      btn.textContent = 'Zipping...';
      const zipBlob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${safeTitle} - Full Set.zip`;
      a.click();
      URL.revokeObjectURL(url);

      btn.disabled = false;
      btn.innerHTML = originalText;
    });

    // Search songs
    function searchSongs(query) {
      if (!query.trim()) return [];
      const lower = query.toLowerCase();
      return libraryIndex.filter(song =>
        song.title.toLowerCase().includes(lower) ||
        song.artist.toLowerCase().includes(lower)
      ).slice(0, 20);
    }

    // Render search results
    function showSearchResults(results) {
      if (results.length === 0) {
        hideSearchResults();
        return;
      }

      searchResultsEl.innerHTML = results.map((song, i) => `
        <div class="search-result${i === selectedResultIndex ? ' selected' : ''}" data-path="${song.path}">
          <span class="key">${song.key || ''}</span>
          <div class="title">${escapeHtml(song.title)}</div>
          <div class="artist">${escapeHtml(song.artist)}</div>
        </div>
      `).join('');
      searchResultsEl.classList.add('visible');
    }

    function hideSearchResults() {
      searchResultsEl.classList.remove('visible');
      selectedResultIndex = -1;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Random song
    function loadRandomSong() {
      if (libraryIndex.length === 0) return;
      const randomIndex = Math.floor(Math.random() * libraryIndex.length);
      const song = libraryIndex[randomIndex];
      loadSong(song.path);
    }

    // Event listeners
    songSearchEl.addEventListener('input', (e) => {
      const results = searchSongs(e.target.value);
      selectedResultIndex = -1;
      showSearchResults(results);
    });

    songSearchEl.addEventListener('focus', () => {
      if (songSearchEl.value.trim()) {
        const results = searchSongs(songSearchEl.value);
        showSearchResults(results);
      }
    });

    songSearchEl.addEventListener('keydown', (e) => {
      const results = searchResultsEl.querySelectorAll('.search-result');
      if (results.length === 0) return;

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedResultIndex = Math.min(selectedResultIndex + 1, results.length - 1);
        showSearchResults(searchSongs(songSearchEl.value));
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedResultIndex = Math.max(selectedResultIndex - 1, 0);
        showSearchResults(searchSongs(songSearchEl.value));
      } else if (e.key === 'Enter' && selectedResultIndex >= 0) {
        e.preventDefault();
        const selected = results[selectedResultIndex];
        if (selected) loadSong(selected.dataset.path);
      } else if (e.key === 'Escape') {
        hideSearchResults();
      }
    });

    searchResultsEl.addEventListener('click', (e) => {
      const result = e.target.closest('.search-result');
      if (result) loadSong(result.dataset.path);
    });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.search-container')) {
        hideSearchResults();
      }
    });

    randomBtn.addEventListener('click', loadRandomSong);

    // Load library on startup
    loadLibraryIndex();

    // Number to Letter conversion utilities
    const CHROMATIC_SHARPS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const CHROMATIC_FLATS = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const MAJOR_SCALE_INTERVALS = [0, 2, 4, 5, 7, 9, 11];
    const FLAT_KEYS = new Set(['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb']);

    // Properly spelled major scales (music theory requires unique letter names)
    const MAJOR_SCALES = {
      'C':  ['C',  'D',  'E',  'F',  'G',  'A',  'B'],
      'G':  ['G',  'A',  'B',  'C',  'D',  'E',  'F#'],
      'D':  ['D',  'E',  'F#', 'G',  'A',  'B',  'C#'],
      'A':  ['A',  'B',  'C#', 'D',  'E',  'F#', 'G#'],
      'E':  ['E',  'F#', 'G#', 'A',  'B',  'C#', 'D#'],
      'B':  ['B',  'C#', 'D#', 'E',  'F#', 'G#', 'A#'],
      'F#': ['F#', 'G#', 'A#', 'B',  'C#', 'D#', 'E#'],
      'C#': ['C#', 'D#', 'E#', 'F#', 'G#', 'A#', 'B#'],
      'F':  ['F',  'G',  'A',  'Bb', 'C',  'D',  'E'],
      'Bb': ['Bb', 'C',  'D',  'Eb', 'F',  'G',  'A'],
      'Eb': ['Eb', 'F',  'G',  'Ab', 'Bb', 'C',  'D'],
      'Ab': ['Ab', 'Bb', 'C',  'Db', 'Eb', 'F',  'G'],
      'Db': ['Db', 'Eb', 'F',  'Gb', 'Ab', 'Bb', 'C'],
      'Gb': ['Gb', 'Ab', 'Bb', 'Cb', 'Db', 'Eb', 'F'],
      'Cb': ['Cb', 'Db', 'Eb', 'Fb', 'Gb', 'Ab', 'Bb'],
    };

    function getNoteIndex(note) {
      let idx = CHROMATIC_SHARPS.indexOf(note);
      if (idx === -1) idx = CHROMATIC_FLATS.indexOf(note);
      // Handle Cb, Fb, E#, B#
      if (idx === -1) {
        if (note === 'Cb') idx = 11;
        else if (note === 'Fb') idx = 4;
        else if (note === 'E#') idx = 5;
        else if (note === 'B#') idx = 0;
      }
      return idx;
    }

    function getNoteAtIndex(index, preferFlats) {
      const normalizedIndex = ((index % 12) + 12) % 12;
      return preferFlats ? CHROMATIC_FLATS[normalizedIndex] : CHROMATIC_SHARPS[normalizedIndex];
    }

    function getMajorScale(keyRoot) {
      // Use properly spelled scales from lookup
      if (MAJOR_SCALES[keyRoot]) {
        return MAJOR_SCALES[keyRoot];
      }
      // Fallback
      const rootIndex = getNoteIndex(keyRoot);
      if (rootIndex === -1) return null;
      const preferFlats = FLAT_KEYS.has(keyRoot);
      return MAJOR_SCALE_INTERVALS.map(interval => getNoteAtIndex(rootIndex + interval, preferFlats));
    }

    function numberToLetter(chordStr, key) {
      // Handle chromatic prefix (b7, #4, etc.)
      const chromaticMatch = chordStr.match(/^([#b])([1-7])(.*)$/);
      if (chromaticMatch) {
        const [, alteration, degreeStr, rest] = chromaticMatch;
        const degree = parseInt(degreeStr, 10);
        const scale = getMajorScale(key);
        if (!scale) return chordStr;

        const baseNote = scale[degree - 1];
        const baseIndex = getNoteIndex(baseNote);
        let targetIndex = baseIndex;
        if (alteration === '#') targetIndex = (baseIndex + 1) % 12;
        else if (alteration === 'b') targetIndex = (baseIndex + 11) % 12;

        const root = getNoteAtIndex(targetIndex, FLAT_KEYS.has(key));
        return root + rest;
      }

      // Parse regular number chord
      const match = chordStr.match(/^([1-7])(.*)$/);
      if (!match) return chordStr;

      const [, degreeStr, quality] = match;
      const degree = parseInt(degreeStr, 10);
      const scale = getMajorScale(key);
      if (!scale) return chordStr;

      const root = scale[degree - 1];

      // Handle slash chord bass note
      const slashMatch = quality.match(/^([^/]*)\/([#b]?[1-7])$/);
      if (slashMatch) {
        const [, chordQuality, bassNum] = slashMatch;
        const bassDegree = parseInt(bassNum.replace(/[#b]/, ''), 10);
        let bassNote = scale[bassDegree - 1];

        // Handle chromatic bass
        if (bassNum.startsWith('#')) {
          const idx = getNoteIndex(bassNote);
          bassNote = getNoteAtIndex((idx + 1) % 12, FLAT_KEYS.has(key));
        } else if (bassNum.startsWith('b')) {
          const idx = getNoteIndex(bassNote);
          bassNote = getNoteAtIndex((idx + 11) % 12, FLAT_KEYS.has(key));
        }

        return root + chordQuality + '/' + bassNote;
      }

      return root + quality;
    }

    function convertChordToLetter(chord, key) {
      if (!chord.isNumber) return chord;

      const fullChord = chord.root + (chord.quality || '') + (chord.bass ? '/' + chord.bass : '');
      const converted = numberToLetter(fullChord, key);

      // Re-parse the converted chord
      const letterMatch = converted.match(/^([A-G][#b]?)(.*?)(?:\/([A-G][#b]?))?$/);
      if (!letterMatch) return chord;

      const [, root, quality, bass] = letterMatch;
      return {
        root,
        quality: quality || undefined,
        bass: bass || undefined,
        isNumber: false
      };
    }

    // Render key control
    const renderKeySelect = document.getElementById('render-key');

    renderKeySelect.addEventListener('change', () => {
      render();
    });

    // Display mode control
    const displayModeSelect = document.getElementById('display-mode');

    displayModeSelect.addEventListener('change', () => {
      renderer.config.displayMode = displayModeSelect.value;
      renderer.layout = renderer.calculateLayout();
      currentPage = 0;
      renderer.renderPage(canvas, currentPage);
      updatePageControls();
    });

    // Override render to apply key conversion and display mode
    const originalRender = render;
    render = function() {
      try {
        errorEl.style.display = 'none';
        const input = inputEl.value;
        let song = parseChordPro(input);

        // Apply display mode
        renderer.config.displayMode = displayModeSelect.value;

        const selectedKey = renderKeySelect.value;

        // Convert to letter notation if a key is selected (not "numbers")
        if (selectedKey !== 'numbers') {
          song = convertSongToLetters(song, selectedKey);
          song.key = selectedKey;
          renderer.config.numbersMode = false;
        } else {
          renderer.config.numbersMode = true;
        }

        renderer.loadSong(song);
        currentPage = 0;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      } catch (e) {
        errorEl.textContent = 'Error: ' + e.message;
        errorEl.style.display = 'block';
        console.error(e);
      }
    };

    function convertSongToLetters(song, key) {
      return {
        ...song,
        sections: song.sections.map(section => ({
          ...section,
          lines: section.lines.map(line => {
            // Skip dynamics lines (no chords to convert)
            if (line.type === 'dynamics') return line;
            return {
              ...line,
              chords: (line.chords || []).map(cp => ({
                ...cp,
                chord: convertChordToLetter(cp.chord, key)
              }))
            };
          })
        }))
      };
    }

    // Initial load - fetch default song from library
    loadSong('You Are My Refuge.txt');
    updateButtonStates();
  </script>
</body>
</html>
