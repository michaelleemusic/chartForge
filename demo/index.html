<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>chartForge Renderer Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    body {
      font-family: 'Lato', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
    }

    .app-container {
      display: flex;
      height: 100vh;
    }

    /* Left Panel - Editor */
    .editor-panel {
      width: 50%;
      min-width: 300px;
      display: flex;
      flex-direction: column;
      background: white;
      border-right: 1px solid #ddd;
    }

    .editor-header {
      padding: 12px 16px;
      border-bottom: 1px solid #eee;
      background: #fafafa;
    }

    .editor-header h1 {
      margin: 0;
      font-size: 18px;
      color: #333;
    }

    .toolbar {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      border-bottom: 1px solid #eee;
      align-items: center;
      flex-wrap: wrap;
    }

    .search-container {
      position: relative;
      flex: 1;
      min-width: 200px;
    }

    .search-input {
      width: 100%;
      padding: 8px 12px;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: white;
    }

    .search-input:focus {
      outline: none;
      border-color: #4a4a4a;
      box-shadow: 0 0 0 2px rgba(74, 74, 74, 0.2);
    }

    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: white;
      border: 1px solid #ccc;
      border-top: none;
      border-radius: 0 0 6px 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 100;
      display: none;
    }

    .search-results.visible {
      display: block;
    }

    .search-result {
      padding: 10px 14px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }

    .search-result:last-child {
      border-bottom: none;
    }

    .search-result:hover,
    .search-result.selected {
      background: #f0f0f0;
    }

    .search-result .title {
      font-weight: 500;
      color: #333;
    }

    .search-result .artist {
      font-size: 12px;
      color: #666;
      margin-top: 2px;
    }

    .search-result .key {
      font-size: 11px;
      color: #999;
      float: right;
    }

    .toolbar-btn {
      padding: 8px 12px;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    .toolbar-btn:hover {
      border-color: #999;
      background: #f5f5f5;
    }

    .toolbar-btn-danger {
      color: #c62828;
    }

    .toolbar-btn-danger:hover:not(:disabled) {
      background: #ffebee;
      border-color: #c62828;
    }

    .toolbar-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .toolbar-divider {
      width: 1px;
      height: 24px;
      background: #ddd;
      margin: 0 4px;
    }

    .toolbar select {
      padding: 8px 12px;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
      padding-right: 30px;
    }

    .toolbar select:hover {
      border-color: #999;
    }

    .toolbar select:focus {
      outline: none;
      border-color: #4a4a4a;
      box-shadow: 0 0 0 2px rgba(74, 74, 74, 0.2);
    }

    .editor-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #input {
      flex: 1;
      width: 100%;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 13px;
      line-height: 1.5;
      padding: 16px;
      border: none;
      resize: none;
      outline: none;
    }

    .error {
      color: #d32f2f;
      background: #ffebee;
      padding: 10px 16px;
      font-size: 13px;
      display: none;
    }

    /* Right Panel - Preview */
    .preview-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #4a4a4a;
      min-width: 400px;
    }

    .preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 16px;
      background: #3a3a3a;
    }

    .page-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .page-controls button {
      padding: 6px 14px;
      font-size: 13px;
      border: 1px solid #666;
      border-radius: 6px;
      background: #4a4a4a;
      color: white;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .page-controls button:hover:not(:disabled) {
      background: #5a5a5a;
      border-color: #777;
    }

    .page-controls button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .page-controls span {
      font-size: 13px;
      color: #ccc;
    }

    .download-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      font-size: 13px;
      border: 1px solid #666;
      border-radius: 6px;
      background: #4a4a4a;
      color: white;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .download-btn:hover {
      background: #5a5a5a;
      border-color: #777;
    }

    .download-btn svg {
      flex-shrink: 0;
    }

    .preview-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 20px;
      overflow: auto;
    }

    #chart-canvas {
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      max-width: 100%;
      height: auto;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .app-container {
        flex-direction: column;
      }

      .editor-panel {
        width: 100%;
        height: 50%;
        border-right: none;
        border-bottom: 1px solid #ddd;
      }

      .preview-panel {
        min-width: unset;
        height: 50%;
      }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
  <div class="app-container">
    <!-- Editor Panel (Left) -->
    <div class="editor-panel">
      <div class="editor-header">
        <h1>chartForge</h1>
      </div>
      <div class="toolbar">
        <div class="search-container">
          <input type="text" class="search-input" id="song-search" placeholder="Search 676 songs..." autocomplete="off">
          <div class="search-results" id="search-results"></div>
        </div>
        <button class="toolbar-btn" id="random-btn">Random</button>
        <div class="toolbar-divider"></div>
        <button class="toolbar-btn" id="new-btn">New</button>
        <button class="toolbar-btn" id="update-btn">Update</button>
        <button class="toolbar-btn toolbar-btn-danger" id="delete-btn">Delete</button>
        <div class="toolbar-divider"></div>
        <select id="render-key">
          <option value="numbers">Numbers</option>
          <option value="C">Key of C</option>
          <option value="Db">Key of Db</option>
          <option value="D">Key of D</option>
          <option value="Eb">Key of Eb</option>
          <option value="E">Key of E</option>
          <option value="F">Key of F</option>
          <option value="Gb">Key of Gb</option>
          <option value="G">Key of G</option>
          <option value="Ab">Key of Ab</option>
          <option value="A">Key of A</option>
          <option value="Bb">Key of Bb</option>
          <option value="B">Key of B</option>
        </select>
      </div>
      <div class="editor-content">
        <textarea id="input">{title: Test Song}
{artist: chartForge Demo}
{key: G}
{tempo: 120}
{time: 4/4}

{section: Intro}
{dynamics: Piano & Pad}
[1] [4sus2] [1] [4sus2]
[1] [5sus4] [6m] [4]

{section: Verse 1}
{dynamics: Add Acoustic Guitar}
The[4] sun comes[1] up, it's a n[5]ew day da[6m]wning;
[4]It's time to[1] sing Your son[5]g ag[6m]ain.
[4]Whatever may [1]pass, and what[5]ever lies be[6m]fore me,
[42]Let me be s[1]inging when the [5sus4]even--in[5]g co[1]mes.

{section: Pre Chorus 1}
Then through the darkness [4sus2]
Your loving kindness [1]
Tore through the shadows [6m7]of my soul [5sus4]
The work is finished [1]the end is written [5sus4]
Jesus Christ [4sus2]my living [5sus4]hope

{section: Chorus}
{dynamics: Full Band}
Bless the[4] Lord, O my[1] soul,[5/7] O my [6m]soul,
[4]Worship His ho[1]ly n[5sus4]ame.    [5]
Sing like [4]never be[6m]fore, [4]   [5]O m[6m]y soul.
I'll[4] worship Your ho[5]ly na[4/1]me.   [1]

{section: Interlude}
[1] [4] [1] [5]

{section: Verse 2}
{dynamics: Bring Dynamics Down}
You're [4]rich in[1] love, and You're[5] slow to [6m]anger.
Your[4] name is g[1]reat, and Your h[5]eart is ki[6m]nd.
For[4] all Your [1]goodness, I will[5] keep on[6m] singing;
[42]Ten thousand[1] reasons for my[5sus4] heart t[5]o fi[1]nd.

{section: Pre Chorus 2}
O [1]for a thousand tongues to sing my great Redeemer's [5]praise,
The gl[1]ories of my [4]God and King, the [1]triumphs of [5]His [1]grace!

{section: Chorus}
{dynamics: Build Back Up}
Bless the[4] Lord, O my[1] soul,[5/7] O my [6m]soul,
[4]Worship His ho[1]ly n[5sus4]ame.    [5]
Sing like [4]never be[6m]fore, [4]   [5]O m[6m]y soul.
I'll[4] worship Your ho[5]ly na[4/1]me.   [1]

{section: Bridge}
{dynamics: Drums Half Time}
All gl[4]ory to [1/3]You, All gl[5]ory to You[1]
For[4]ever, and [1/3]ever, and [5]ever
All gl[4]ory to [1/3]You, All gl[5]ory to You[1]
For[4]ever, and [1/3]ever, and [5]ever Amen    [1]

{section: Verse 3}
And[4] on that[1] day when my[5] strength is f[6m]ailing,
The[4] end draws[1] near, and my[5] time has [6m]come;
[4]Still my[1] soul will sing Your [5]praise un[6m]ending:
[42]Ten thousand[1] years and then fo[5sus4]re----ve[5]rmo[1]re!

{section: Instrumental}
{dynamics: Guitar Solo}
[1] [b7] [4] [57] [1]
[1] [b7] [4] [57] [1]
[1] [b7] [4] [5sus7] [57]

{section: Chorus}
{dynamics: Everyone In}
Bless the[4] Lord, O my[1] soul,[5/7] O my [6m]soul,
[4]Worship His ho[1]ly n[5sus4]ame.    [5]
Sing like [4]never be[6m]fore, [4]   [5]O m[6m]y soul.
I'll[4] worship Your ho[5]ly na[4/1]me.   [1]

{section: Verse 4}
[1]You are ex[b7]alted Lord, [4]above [57]all e[1]lse
[1]We place you at the hi[b7]ghest place, a[4]bove [57]all [1]else
[1]Right here where we st[b7]and and every[4]where [57]we [1]go
[1]We place you at the hi[b7]ghest place, so the [4]world will [57]know

{section: Bridge}
{dynamics: Half Time Feel}
[1]You are a mighty [b7]warrior, [4]dressed in armor of l[1]ight
[1]Crushing the deeds of da[b7]rkness, l[4]ead us on in the[1] fight
[1]Through the blood of J[b7]esus, vic[4]torious we [1]stand
[1]We place you at the h[b7]ighest place, a[4]bove all else in this [5sus7]land    [57]

{section: Chorus}
Bless the[4] Lord, O my[1] soul,[5/7] O my [6m]soul,
[4]Worship His ho[1]ly n[5sus4]ame.    [5]
Sing like [4]never be[6m]fore, [4]   [5]O m[6m]y soul.
I'll[4] worship Your ho[5]ly na[4/1]me.   [1]

{section: Vamp}
{dynamics: Bass & Drums Only}
[1] [5] [6m] [4]
[1] [5] [6m] [4]
[1] [5] [6m] [4]
[1] [5] [6m] [4]

{section: Verse 5}
{dynamics: Rebuild Slowly}
Je[1]sus! the name that charms our fears, that bids our sorrows [5]cease;
'Tis m[1]usic in the [4]sinner's ears, 'tis [1]life, and health, and [5]pe[1]ace.
He [1]breaks the power of canceled sin, He sets the prisoner [5]free;
His bl[1]ood can ma[4]ke the foulest clean; His [1]blood availed [5]for [1]me.

{section: Pre Chorus 3}
My [1]gracious Master and my God, assist me to [5]proclaim,
To sp[1]read through all the [4]earth abroad the [1]honors of [5]Thy [1]name.

{section: Chorus}
{dynamics: Full Energy}
Bless the[4] Lord, O my[1] soul,[5/7] O my [6m]soul,
[4]Worship His ho[1]ly n[5sus4]ame.    [5]
Sing like [4]never be[6m]fore, [4]   [5]O m[6m]y soul.
I'll[4] worship Your ho[5]ly na[4/1]me.   [1]

{section: Turnaround}
[1] [4] [6m] [5]
[1] [4] [6m] [5]

{section: Bridge}
{dynamics: Spontaneous Worship}
All gl[4]ory to [1/3]You, All gl[5]ory to You[1]
For[4]ever, and [1/3]ever, and [5]ever
All gl[4]ory to [1/3]You, All gl[5]ory to You[1]
For[4]ever, and [1/3]ever, and [5]ever Amen    [1]

{section: Tag}
[6m]I'll wor[4]ship Your [5]holy n[6m]ame.
Yes, I'll [4]worship Your [5]holy na[1]me.
[6m]I'll wor[4]ship Your [5]holy n[6m]ame.
Yes, I'll [4]worship Your [5]holy na[1]me.

{section: Outro}
{dynamics: Drums & Bass Out}
[1] [4sus2] [1] [4sus2]
[1] [5sus4] [6m] [4]
[1]

{section: Ending}
{dynamics: Piano Only}
[1]</textarea>
        <div class="error" id="error"></div>
      </div>
    </div>

    <!-- Preview Panel (Right) -->
    <div class="preview-panel">
      <div class="preview-header">
        <div class="page-controls">
          <button id="prev-btn" disabled>&larr; Prev</button>
          <span id="page-info">Page 1 of 1</span>
          <button id="next-btn" disabled>Next &rarr;</button>
        </div>
        <button class="download-btn" id="download-pdf-btn" title="Download PDF">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
          PDF
        </button>
      </div>
      <div class="preview-container">
        <canvas id="chart-canvas"></canvas>
      </div>
    </div>
  </div>

  <script type="module">
    // Import from the compiled dist folder
    // Note: For this to work, you need to serve this from a local server
    // or use a bundler. For simplicity, we'll inline the necessary code.

    // Sample Song data structure (matches the parsed output)
    const SECTION_ABBREVIATIONS = {
      intro: 'I',
      verse: 'V',
      prechorus: 'Pr',
      chorus: 'C',
      bridge: 'B',
      outro: 'O',
      tag: 'Tg',
      instrumental: 'Inst',
      interlude: 'It',
      vamp: 'Vp',
      turnaround: 'T',
      ending: 'E',
      custom: ''
    };

    const SECTION_NAMES = {
      intro: 'INTRO',
      verse: 'VERSE',
      prechorus: 'PRE CHORUS',
      chorus: 'CHORUS',
      bridge: 'BRIDGE',
      outro: 'OUTRO',
      tag: 'TAG',
      instrumental: 'INSTRUMENTAL',
      interlude: 'INTERLUDE',
      vamp: 'VAMP',
      turnaround: 'TURNAROUND',
      ending: 'ENDING',
      custom: ''
    };

    // Default render configuration
    const DEFAULT_CONFIG = {
      page: { width: 816, height: 1056 },
      margins: { top: 40, right: 40, bottom: 60, left: 40 },
      columnGap: 30,
      fonts: {
        title: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 28, weight: 'bold', lineHeight: 1.2 },
        artist: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 14, weight: 'normal', lineHeight: 1.4 },
        metadata: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 12, weight: 'normal', lineHeight: 1.4 },
        sectionName: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 13, weight: 'bold', lineHeight: 1.4 },
        chordRoot: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 14, weight: 'bold', lineHeight: 1.3 },
        chordQuality: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 10, weight: 'normal', lineHeight: 1.3 },
        lyrics: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 13, weight: 'normal', lineHeight: 1.4 },
        dynamics: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 11, weight: '300', lineHeight: 1.4 },
        roadmapBadge: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 10, weight: 'normal', lineHeight: 1 },
        pageNumber: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 12, weight: 'normal', lineHeight: 1.4 }
      },
      colors: {
        background: '#ffffff',
        text: '#1a1a1a',
        textSecondary: '#333333',
        textMuted: '#888888',
        badgeFill: '#4a4a4a',
        badgeText: '#ffffff',
        rule: '#cccccc',
        roadmapInactive: '#666666'
      },
      badgeRadius: 11,
      roadmapBadgeRadius: 12,
      spacing: {
        afterHeader: 15,
        afterRoadmap: 20,
        betweenSections: 18,
        betweenLines: 4,
        chordToLyric: 2,
        sectionHeaderHeight: 28,
        roadmapHeight: 36
      }
    };

    // Simple ChordPro parser for demo
    function parseChordPro(input) {
      const song = {
        title: 'Untitled',
        artist: 'Unknown',
        key: 'C',
        tempo: null,
        timeSignature: '4/4',
        sections: []
      };

      const lines = input.split(/\r?\n/);
      let currentSection = null;
      let pendingDynamics = null;

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        // Parse directives
        const directiveMatch = trimmed.match(/^\{(\w+):\s*(.+?)\}$/);
        if (directiveMatch) {
          const [, directive, value] = directiveMatch;
          switch (directive.toLowerCase()) {
            case 'title':
            case 't':
              song.title = value;
              break;
            case 'artist':
            case 'a':
              song.artist = value;
              break;
            case 'key':
            case 'k':
              song.key = value;
              break;
            case 'tempo':
              song.tempo = parseInt(value, 10);
              break;
            case 'time':
              song.timeSignature = value;
              break;
            case 'section':
              // Start new section
              const sectionInfo = parseSectionName(value);
              currentSection = {
                type: sectionInfo.type,
                number: sectionInfo.number,
                label: sectionInfo.label,
                dynamics: pendingDynamics,
                lines: []
              };
              pendingDynamics = null;
              song.sections.push(currentSection);
              break;
            case 'dynamics':
              if (currentSection) {
                currentSection.dynamics = value;
              } else {
                pendingDynamics = value;
              }
              break;
          }
          continue;
        }

        // Parse chord/lyric lines
        if (currentSection && trimmed.includes('[')) {
          const parsedLine = parseChordLine(trimmed);
          currentSection.lines.push(parsedLine);
        } else if (currentSection && !trimmed.startsWith('{')) {
          // Plain lyrics without chords
          currentSection.lines.push({ lyrics: trimmed, chords: [] });
        }
      }

      return song;
    }

    function parseSectionName(value) {
      const lower = value.toLowerCase().replace(/\s+/g, '');

      // Check for numbered sections
      const numberMatch = value.match(/(\d+)$/);
      const number = numberMatch ? parseInt(numberMatch[1], 10) : undefined;
      const baseName = value.replace(/\s*\d+$/, '').toLowerCase().replace(/\s+/g, '');

      const typeMap = {
        'intro': 'intro',
        'verse': 'verse',
        'prechorus': 'prechorus',
        'pre-chorus': 'prechorus',
        'chorus': 'chorus',
        'bridge': 'bridge',
        'outro': 'outro',
        'tag': 'tag',
        'instrumental': 'instrumental',
        'interlude': 'interlude',
        'vamp': 'vamp',
        'turnaround': 'turnaround',
        'ending': 'ending'
      };

      return {
        type: typeMap[baseName] || 'custom',
        number,
        label: typeMap[baseName] ? null : value
      };
    }

    function parseChordLine(line) {
      const chords = [];
      let lyrics = '';
      let position = 0;
      let i = 0;

      while (i < line.length) {
        if (line[i] === '[') {
          const end = line.indexOf(']', i);
          if (end > i) {
            const chordStr = line.substring(i + 1, end);
            const chord = parseChordString(chordStr);
            chords.push({ chord, position });
            i = end + 1;
            continue;
          }
        }
        lyrics += line[i];
        position++;
        i++;
      }

      return { lyrics: lyrics.trim() || undefined, chords };
    }

    function parseChordString(str) {
      // First check for number chords (Nashville notation): 1, 2, 42, 6m7, 1/3, etc.
      const numberMatch = str.match(/^([#b]?[1-7])(.*?)(?:\/([#b]?[1-7]))?$/);
      if (numberMatch) {
        const [, root, quality, bass] = numberMatch;
        return {
          root,
          quality: quality || undefined,
          bass: bass || undefined,
          isNumber: true
        };
      }

      // Match letter chords: root, quality, and optional bass note
      const match = str.match(/^([A-G][#b]?)(.*?)(?:\/([A-G][#b]?))?$/);
      if (!match) return { root: str };

      const [, root, quality, bass] = match;
      return {
        root,
        quality: quality || undefined,
        bass: bass || undefined,
        isNumber: false
      };
    }

    // Renderer implementation
    class ChartRenderer {
      constructor(config = DEFAULT_CONFIG) {
        this.config = config;
        this.song = null;
        this.layout = null;
        this.pixelRatio = window.devicePixelRatio || 1;
      }

      loadSong(song) {
        this.song = song;
        this.layout = this.calculateLayout();
      }

      calculateLayout() {
        if (!this.song) return null;

        const contentWidth = this.config.page.width - this.config.margins.left - this.config.margins.right;
        const columnWidth = (contentWidth - this.config.columnGap) / 2;

        const headerHeight =
          this.config.fonts.title.size * this.config.fonts.title.lineHeight +
          this.config.fonts.artist.size * this.config.fonts.artist.lineHeight +
          this.config.spacing.afterHeader;

        const roadmapHeight = this.config.spacing.roadmapHeight + this.config.spacing.afterRoadmap;
        const contentStartY = this.config.margins.top + headerHeight + roadmapHeight;
        const columnHeight = this.config.page.height - contentStartY - this.config.margins.bottom;

        const sections = [];
        let page = 0;
        let column = 0;
        let columnY = 0;

        const advanceColumn = () => {
          if (column === 0) {
            column = 1;
            columnY = 0;
          } else {
            page++;
            column = 0;
            columnY = 0;
          }
        };

        for (let i = 0; i < this.song.sections.length; i++) {
          const section = this.song.sections[i];
          const sectionHeight = this.calculateSectionHeight(section);

          // If section doesn't fit and we're not at top, move to next column/page
          if (columnY > 0 && columnY + sectionHeight > columnHeight) {
            advanceColumn();
          }

          sections.push({
            sectionIndex: i,
            column,
            y: columnY,
            height: sectionHeight,
            page
          });

          columnY += sectionHeight + this.config.spacing.betweenSections;

          // If exceeded column height, next section goes to new column
          if (columnY >= columnHeight) {
            advanceColumn();
          }
        }

        return {
          pageCount: page + 1,
          sections,
          columnWidth,
          columnHeight,
          contentStartY,
          column1X: this.config.margins.left,
          column2X: this.config.margins.left + columnWidth + this.config.columnGap
        };
      }

      calculateSectionHeight(section) {
        let height = this.config.badgeRadius * 2 + 6;

        if (section.dynamics) {
          height += 4;
        }

        for (let i = 0; i < section.lines.length; i++) {
          const line = section.lines[i];
          const hasChords = line.chords && line.chords.length > 0;
          const hasLyrics = line.lyrics && line.lyrics.trim().length > 0;
          const isChordOnly = hasChords && !hasLyrics;

          if (isChordOnly) {
            height += this.config.fonts.chordRoot.size * this.config.fonts.chordRoot.lineHeight;
          } else if (hasChords && hasLyrics) {
            height += this.config.fonts.chordRoot.size * this.config.fonts.chordRoot.lineHeight;
            height += this.config.spacing.chordToLyric;
            height += this.config.fonts.lyrics.size * this.config.fonts.lyrics.lineHeight;
          } else if (hasLyrics) {
            height += this.config.fonts.lyrics.size * this.config.fonts.lyrics.lineHeight;
          }

          if (i < section.lines.length - 1) {
            height += this.config.spacing.betweenLines;
          }
        }

        return height;
      }

      renderPage(canvas, pageIndex) {
        if (!this.song || !this.layout) return;

        const { width, height } = this.config.page;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        canvas.width = width * this.pixelRatio;
        canvas.height = height * this.pixelRatio;

        const ctx = canvas.getContext('2d');
        ctx.scale(this.pixelRatio, this.pixelRatio);

        // Clear background
        ctx.fillStyle = this.config.colors.background;
        ctx.fillRect(0, 0, width, height);

        // Render header
        let y = this.renderHeader(ctx, pageIndex);

        // Render roadmap (first page only)
        if (pageIndex === 0) {
          y = this.renderRoadmap(ctx, y);
          y += this.config.spacing.afterRoadmap;
        }

        // Render sections
        const pageSections = this.layout.sections.filter(s => s.page === pageIndex);

        for (const layoutSection of pageSections) {
          const section = this.song.sections[layoutSection.sectionIndex];
          const x = layoutSection.column === 0 ? this.layout.column1X : this.layout.column2X;
          const sectionY = this.layout.contentStartY + layoutSection.y;

          this.renderSection(ctx, section, x, sectionY, this.layout.columnWidth);
        }
      }

      renderHeader(ctx, pageIndex) {
        const config = this.config;
        let y = config.margins.top;

        if (pageIndex === 0) {
          // Title
          ctx.font = `${config.fonts.title.weight} ${config.fonts.title.size}px ${config.fonts.title.family}`;
          ctx.fillStyle = config.colors.text;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(this.song.title, config.margins.left, y);

          // Page number
          ctx.font = `${config.fonts.pageNumber.weight} ${config.fonts.pageNumber.size}px ${config.fonts.pageNumber.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'right';
          ctx.fillText(`Page: ${pageIndex + 1}/${this.layout.pageCount}`, config.page.width - config.margins.right, y);

          y += config.fonts.title.size * config.fonts.title.lineHeight;

          // Artist
          ctx.font = `${config.fonts.artist.weight} ${config.fonts.artist.size}px ${config.fonts.artist.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'left';
          ctx.fillText(this.song.artist, config.margins.left, y);

          // Metadata
          ctx.font = `${config.fonts.metadata.weight} ${config.fonts.metadata.size}px ${config.fonts.metadata.family}`;
          ctx.textAlign = 'right';
          const meta = [];
          if (this.song.key) meta.push(`Key: ${this.song.key}`);
          if (this.song.tempo) meta.push(`Tempo: ${this.song.tempo}`);
          if (this.song.timeSignature) meta.push(`Time: ${this.song.timeSignature}`);
          ctx.fillText(meta.join('  '), config.page.width - config.margins.right, y);

          y += config.fonts.artist.size * config.fonts.artist.lineHeight;
        } else {
          // Compact header
          ctx.font = `bold ${config.fonts.sectionName.size + 4}px ${config.fonts.title.family}`;
          ctx.fillStyle = config.colors.text;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(this.song.title, config.margins.left, y);

          ctx.font = `${config.fonts.pageNumber.weight} ${config.fonts.pageNumber.size}px ${config.fonts.pageNumber.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'right';
          ctx.fillText(`Page: ${pageIndex + 1}/${this.layout.pageCount}`, config.page.width - config.margins.right, y);

          y += (config.fonts.sectionName.size + 4) * 1.4;
        }

        return y + config.spacing.afterHeader;
      }

      renderRoadmap(ctx, y) {
        const config = this.config;
        const entries = this.generateRoadmap();
        let x = config.margins.left;

        for (const entry of entries) {
          const radius = config.roadmapBadgeRadius;
          const centerY = y + radius;

          // Draw circle (outline for roadmap)
          ctx.beginPath();
          ctx.arc(x + radius, centerY, radius, 0, Math.PI * 2);
          ctx.strokeStyle = config.colors.roadmapInactive;
          ctx.lineWidth = 1.5;
          ctx.stroke();

          // Draw abbreviation
          ctx.font = `${config.fonts.roadmapBadge.weight} ${config.fonts.roadmapBadge.size}px ${config.fonts.roadmapBadge.family}`;
          ctx.fillStyle = config.colors.roadmapInactive;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(entry.abbreviation, x + radius, centerY);

          // Superscript for repeat count
          if (entry.repeatCount > 1) {
            const superSize = config.fonts.roadmapBadge.size * 0.75;
            ctx.font = `${config.fonts.roadmapBadge.weight} ${superSize}px ${config.fonts.roadmapBadge.family}`;
            ctx.fillStyle = config.colors.text;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(entry.repeatCount.toString(), x + radius * 2 - 2, y - 2);
          }

          x += radius * 2 + 8;
        }

        return y + config.spacing.roadmapHeight;
      }

      generateRoadmap() {
        const entries = [];
        let currentAbbr = '';
        let currentCount = 0;

        for (const section of this.song.sections) {
          let abbr = SECTION_ABBREVIATIONS[section.type] || '';
          if (section.number) abbr += section.number;
          if (section.type === 'custom' && section.label) {
            abbr = section.label.substring(0, 2).toUpperCase();
          }

          if (abbr === currentAbbr) {
            currentCount++;
          } else {
            if (currentAbbr) {
              entries.push({ abbreviation: currentAbbr, repeatCount: currentCount > 1 ? currentCount : null });
            }
            currentAbbr = abbr;
            currentCount = 1;
          }
        }

        if (currentAbbr) {
          entries.push({ abbreviation: currentAbbr, repeatCount: currentCount > 1 ? currentCount : null });
        }

        return entries;
      }

      renderSection(ctx, section, x, y, width) {
        const config = this.config;
        let currentY = y;

        // Render badge
        const abbr = this.getSectionAbbreviation(section);
        const radius = config.badgeRadius;

        ctx.beginPath();
        ctx.arc(x + radius, y + radius, radius, 0, Math.PI * 2);
        ctx.fillStyle = config.colors.badgeFill;
        ctx.fill();

        ctx.font = `${config.fonts.roadmapBadge.weight} ${config.fonts.roadmapBadge.size}px ${config.fonts.roadmapBadge.family}`;
        ctx.fillStyle = config.colors.badgeText;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(abbr, x + radius, y + radius);

        // Render section name
        const displayName = this.getSectionDisplayName(section);
        const nameX = x + radius * 2 + 8;
        const nameY = y + radius + 4;

        ctx.font = `${config.fonts.sectionName.weight} ${config.fonts.sectionName.size}px ${config.fonts.sectionName.family}`;
        ctx.fillStyle = config.colors.text;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(displayName, nameX, nameY);

        const nameWidth = ctx.measureText(displayName).width;

        // Horizontal rule
        const ruleStartX = nameX + nameWidth + 10;
        const ruleEndX = x + width;

        if (ruleEndX > ruleStartX + 20) {
          ctx.beginPath();
          ctx.moveTo(ruleStartX, nameY);
          ctx.lineTo(ruleEndX, nameY);
          ctx.strokeStyle = config.colors.rule;
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        // Dynamics
        if (section.dynamics) {
          ctx.font = `${config.fonts.dynamics.weight} ${config.fonts.dynamics.size}px ${config.fonts.dynamics.family}`;
          ctx.fillStyle = config.colors.textMuted;
          ctx.textAlign = 'right';
          ctx.textBaseline = 'top';
          ctx.fillText(section.dynamics, x + width, y + 4);
        }

        currentY += radius * 2 + 6;
        if (section.dynamics) currentY += 4;

        // Render lines
        for (let i = 0; i < section.lines.length; i++) {
          const line = section.lines[i];
          currentY += this.renderLine(ctx, line, x, currentY, width);

          if (i < section.lines.length - 1) {
            currentY += config.spacing.betweenLines;
          }
        }

        return currentY - y;
      }

      renderLine(ctx, line, x, y, width) {
        const config = this.config;
        let currentY = y;
        const hasChords = line.chords && line.chords.length > 0;
        const hasLyrics = line.lyrics && line.lyrics.trim().length > 0;
        const isChordOnly = hasChords && !hasLyrics;

        if (isChordOnly) {
          // Chord-only line
          const chordY = currentY + config.fonts.chordRoot.size;
          this.renderChordRow(ctx, line.chords.map(c => c.chord), x, chordY, width);
          currentY += config.fonts.chordRoot.size * config.fonts.chordRoot.lineHeight;

        } else if (hasChords && hasLyrics) {
          // Chords above lyrics - renders both with stretched spacing
          const chordY = currentY + config.fonts.chordRoot.size;
          currentY += config.fonts.chordRoot.size * config.fonts.chordRoot.lineHeight;
          currentY += config.spacing.chordToLyric;
          const lyricY = currentY;

          this.renderChordsAboveLyrics(ctx, line.chords, line.lyrics, x, chordY, lyricY);
          currentY += config.fonts.lyrics.size * config.fonts.lyrics.lineHeight;

        } else if (hasLyrics) {
          ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(line.lyrics, x, currentY);
          currentY += config.fonts.lyrics.size * config.fonts.lyrics.lineHeight;
        }

        return currentY - y;
      }

      renderChord(ctx, chord, x, y) {
        const config = this.config;
        let currentX = x;

        ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
        ctx.fillStyle = config.colors.text;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(chord.root, currentX, y);
        currentX += ctx.measureText(chord.root).width;

        if (chord.quality) {
          ctx.font = `${config.fonts.chordQuality.weight} ${config.fonts.chordQuality.size}px ${config.fonts.chordQuality.family}`;
          const qualityY = y - (config.fonts.chordRoot.size * 0.25);
          ctx.fillText(chord.quality, currentX, qualityY);
          currentX += ctx.measureText(chord.quality).width;
        }

        if (chord.bass) {
          ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
          ctx.fillText('/' + chord.bass, currentX, y);
          currentX += ctx.measureText('/' + chord.bass).width;
        }

        return currentX - x;
      }

      measureChordWidth(ctx, chord) {
        const config = this.config;
        let width = 0;

        ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
        width += ctx.measureText(chord.root).width;

        if (chord.quality) {
          ctx.font = `${config.fonts.chordQuality.weight} ${config.fonts.chordQuality.size}px ${config.fonts.chordQuality.family}`;
          width += ctx.measureText(chord.quality).width;
        }

        if (chord.bass) {
          ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
          width += ctx.measureText('/' + chord.bass).width;
        }

        return width;
      }

      renderChordRow(ctx, chords, x, y, width) {
        if (chords.length === 0) return;
        if (chords.length === 1) {
          this.renderChord(ctx, chords[0], x, y);
          return;
        }

        const chordWidths = chords.map(c => this.measureChordWidth(ctx, c));
        const totalWidth = chordWidths.reduce((a, b) => a + b, 0);
        const spacing = (width - totalWidth) / chords.length;

        let currentX = x;
        for (let i = 0; i < chords.length; i++) {
          this.renderChord(ctx, chords[i], currentX, y);
          currentX += chordWidths[i] + spacing;
        }
      }

      renderChordsAboveLyrics(ctx, chordPositions, lyrics, x, chordY, lyricY) {
        const config = this.config;

        // Sort by position
        const sorted = [...chordPositions].sort((a, b) => a.position - b.position);

        ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;

        const minGap = 8;
        const positions = [];
        const segments = [];
        let currentX = x;

        // Calculate positions with overlap prevention
        for (let i = 0; i < sorted.length; i++) {
          const cp = sorted[i];
          const prevPos = i === 0 ? 0 : sorted[i - 1].position;
          const segmentText = lyrics.substring(prevPos, cp.position);

          if (segmentText) {
            ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;
            segments.push({ text: segmentText, xPos: currentX });
            currentX += ctx.measureText(segmentText).width;
          }

          const chordWidth = this.measureChordWidth(ctx, cp.chord);

          // Check overlap with previous chord
          if (positions.length > 0) {
            const prev = positions[positions.length - 1];
            const minX = prev.xPos + prev.width + minGap;
            if (currentX < minX) {
              currentX = minX;
            }
          }

          positions.push({ chord: cp.chord, xPos: currentX, width: chordWidth });
        }

        // Add remaining lyrics
        if (sorted.length > 0) {
          const lastPos = sorted[sorted.length - 1].position;
          const remaining = lyrics.substring(lastPos);
          if (remaining) {
            segments.push({ text: remaining, xPos: currentX });
          }
        }

        // Render chords
        for (const p of positions) {
          this.renderChord(ctx, p.chord, p.xPos, chordY);
        }

        // Render stretched lyrics
        ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;
        ctx.fillStyle = config.colors.textSecondary;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';

        for (const seg of segments) {
          ctx.fillText(seg.text, seg.xPos, lyricY);
        }
      }

      getSectionAbbreviation(section) {
        let abbr = SECTION_ABBREVIATIONS[section.type] || '';
        if (section.number) abbr += section.number;
        if (section.type === 'custom' && section.label) {
          abbr = section.label.substring(0, 2).toUpperCase();
        }
        return abbr;
      }

      getSectionDisplayName(section) {
        if (section.label) return section.label.toUpperCase();
        let name = SECTION_NAMES[section.type] || section.type.toUpperCase();
        if (section.number) name += ' ' + section.number;
        return name;
      }
    }

    // Demo app
    const inputEl = document.getElementById('input');
    const canvas = document.getElementById('chart-canvas');
    const errorEl = document.getElementById('error');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const pageInfoEl = document.getElementById('page-info');

    let renderer = new ChartRenderer();
    let currentPage = 0;

    function updatePageControls() {
      const pageCount = renderer.layout ? renderer.layout.pageCount : 1;
      pageInfoEl.textContent = `Page ${currentPage + 1} of ${pageCount}`;
      prevBtn.disabled = currentPage === 0;
      nextBtn.disabled = currentPage >= pageCount - 1;
    }

    function render() {
      try {
        errorEl.style.display = 'none';
        const input = inputEl.value;
        const song = parseChordPro(input);
        renderer.loadSong(song);
        currentPage = 0;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      } catch (e) {
        errorEl.textContent = 'Error: ' + e.message;
        errorEl.style.display = 'block';
        console.error(e);
      }
    }

    // Realtime rendering on textarea input
    inputEl.addEventListener('input', render);

    prevBtn.addEventListener('click', () => {
      if (currentPage > 0) {
        currentPage--;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      }
    });

    nextBtn.addEventListener('click', () => {
      if (renderer.layout && currentPage < renderer.layout.pageCount - 1) {
        currentPage++;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      }
    });

    // Library search functionality
    let libraryIndex = [];
    const songSearchEl = document.getElementById('song-search');
    const searchResultsEl = document.getElementById('search-results');
    const randomBtn = document.getElementById('random-btn');
    let selectedResultIndex = -1;

    // Load library index
    async function loadLibraryIndex() {
      try {
        const response = await fetch('../library/index.json');
        libraryIndex = await response.json();
        songSearchEl.placeholder = `Search ${libraryIndex.length} songs...`;
      } catch (e) {
        console.error('Failed to load library index:', e);
        songSearchEl.placeholder = 'Library unavailable';
      }
    }

    // Track currently loaded song
    let currentSongPath = null;

    // Fetch song content
    async function loadSong(path) {
      try {
        const response = await fetch(`../library/${path}`);
        const content = await response.text();
        inputEl.value = content;
        currentSongPath = path;
        render();
        songSearchEl.value = '';
        hideSearchResults();
        updateButtonStates();
      } catch (e) {
        console.error('Failed to load song:', e);
        errorEl.textContent = 'Error loading song: ' + e.message;
        errorEl.style.display = 'block';
      }
    }

    // Update button states based on current song
    function updateButtonStates() {
      const updateBtn = document.getElementById('update-btn');
      const deleteBtn = document.getElementById('delete-btn');
      deleteBtn.disabled = !currentSongPath;
      // Update button always enabled, but changes label
      updateBtn.textContent = currentSongPath ? 'Update' : 'Save';
    }

    // Extract title from chart content
    function extractTitle(content) {
      const match = content.match(/\{title:\s*(.+?)\}/i);
      return match ? match[1].trim() : 'Untitled';
    }

    // Library management functions
    async function createNewSong() {
      const template = `{title: New Song}
{artist: Artist Name}
{key: C}
{tempo: 120}
{time: 4/4}

{section: Verse 1}
[1] [4] [5] [1]

{section: Chorus}
[1] [5] [6m] [4]
`;
      inputEl.value = template;
      currentSongPath = null;
      render();
      updateButtonStates();
    }

    async function updateSong() {
      if (!currentSongPath) {
        alert('No song loaded from library. Use "New" to create a new song first.');
        return;
      }

      const content = inputEl.value;
      try {
        const response = await fetch(`/api/library/${currentSongPath}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'text/plain' },
          body: content
        });

        if (response.ok) {
          alert('Song updated successfully!');
          // Refresh library index
          await loadLibraryIndex();
        } else {
          throw new Error(await response.text());
        }
      } catch (e) {
        // Fallback: offer download
        console.error('API not available, using download fallback:', e);
        downloadSong(content, currentSongPath);
      }
    }

    async function saveSongAsNew() {
      const content = inputEl.value;
      const title = extractTitle(content);
      const filename = title.replace(/[^a-zA-Z0-9\s]/g, '').trim() + '.txt';

      try {
        const response = await fetch(`/api/library/${filename}`, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain' },
          body: content
        });

        if (response.ok) {
          currentSongPath = filename;
          alert('Song saved to library!');
          await loadLibraryIndex();
          updateButtonStates();
        } else {
          throw new Error(await response.text());
        }
      } catch (e) {
        // Fallback: offer download
        console.error('API not available, using download fallback:', e);
        downloadSong(content, filename);
      }
    }

    async function deleteSong() {
      if (!currentSongPath) {
        alert('No song loaded from library.');
        return;
      }

      const title = extractTitle(inputEl.value);
      if (!confirm(`Move "${title}" to trash?`)) {
        return;
      }

      try {
        const response = await fetch(`/api/library/${currentSongPath}`, {
          method: 'DELETE'
        });

        if (response.ok) {
          alert('Song moved to trash.');
          currentSongPath = null;
          createNewSong();
          await loadLibraryIndex();
        } else {
          throw new Error(await response.text());
        }
      } catch (e) {
        console.error('API not available:', e);
        alert('Delete requires the API server. Run: node demo/server.js');
      }
    }

    function downloadSong(content, filename) {
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      alert(`Downloaded "${filename}". Move it to the library folder manually.`);
    }

    // Library management button handlers
    document.getElementById('new-btn').addEventListener('click', () => {
      if (currentSongPath || inputEl.value.trim()) {
        if (!confirm('Create new song? Unsaved changes will be lost.')) return;
      }
      createNewSong();
    });

    document.getElementById('update-btn').addEventListener('click', () => {
      if (currentSongPath) {
        updateSong();
      } else {
        saveSongAsNew();
      }
    });

    document.getElementById('delete-btn').addEventListener('click', deleteSong);

    // PDF download
    document.getElementById('download-pdf-btn').addEventListener('click', async () => {
      if (!renderer.layout) return;

      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'pt',
        format: [renderer.config.page.width, renderer.config.page.height]
      });

      const title = extractTitle(inputEl.value);
      const pageCount = renderer.layout.pageCount;

      for (let i = 0; i < pageCount; i++) {
        if (i > 0) pdf.addPage();

        // Render page to canvas
        renderer.renderPage(canvas, i);

        // Add canvas as image to PDF
        const imgData = canvas.toDataURL('image/png', 1.0);
        pdf.addImage(imgData, 'PNG', 0, 0, renderer.config.page.width, renderer.config.page.height);
      }

      // Restore current page view
      renderer.renderPage(canvas, currentPage);

      // Download
      const filename = title.replace(/[^a-zA-Z0-9\s]/g, '').trim() + '.pdf';
      pdf.save(filename);
    });

    // Search songs
    function searchSongs(query) {
      if (!query.trim()) return [];
      const lower = query.toLowerCase();
      return libraryIndex.filter(song =>
        song.title.toLowerCase().includes(lower) ||
        song.artist.toLowerCase().includes(lower)
      ).slice(0, 20);
    }

    // Render search results
    function showSearchResults(results) {
      if (results.length === 0) {
        hideSearchResults();
        return;
      }

      searchResultsEl.innerHTML = results.map((song, i) => `
        <div class="search-result${i === selectedResultIndex ? ' selected' : ''}" data-path="${song.path}">
          <span class="key">${song.key || ''}</span>
          <div class="title">${escapeHtml(song.title)}</div>
          <div class="artist">${escapeHtml(song.artist)}</div>
        </div>
      `).join('');
      searchResultsEl.classList.add('visible');
    }

    function hideSearchResults() {
      searchResultsEl.classList.remove('visible');
      selectedResultIndex = -1;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Random song
    function loadRandomSong() {
      if (libraryIndex.length === 0) return;
      const randomIndex = Math.floor(Math.random() * libraryIndex.length);
      const song = libraryIndex[randomIndex];
      loadSong(song.path);
    }

    // Event listeners
    songSearchEl.addEventListener('input', (e) => {
      const results = searchSongs(e.target.value);
      selectedResultIndex = -1;
      showSearchResults(results);
    });

    songSearchEl.addEventListener('focus', () => {
      if (songSearchEl.value.trim()) {
        const results = searchSongs(songSearchEl.value);
        showSearchResults(results);
      }
    });

    songSearchEl.addEventListener('keydown', (e) => {
      const results = searchResultsEl.querySelectorAll('.search-result');
      if (results.length === 0) return;

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedResultIndex = Math.min(selectedResultIndex + 1, results.length - 1);
        showSearchResults(searchSongs(songSearchEl.value));
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedResultIndex = Math.max(selectedResultIndex - 1, 0);
        showSearchResults(searchSongs(songSearchEl.value));
      } else if (e.key === 'Enter' && selectedResultIndex >= 0) {
        e.preventDefault();
        const selected = results[selectedResultIndex];
        if (selected) loadSong(selected.dataset.path);
      } else if (e.key === 'Escape') {
        hideSearchResults();
      }
    });

    searchResultsEl.addEventListener('click', (e) => {
      const result = e.target.closest('.search-result');
      if (result) loadSong(result.dataset.path);
    });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.search-container')) {
        hideSearchResults();
      }
    });

    randomBtn.addEventListener('click', loadRandomSong);

    // Load library on startup
    loadLibraryIndex();

    // Number to Letter conversion utilities
    const CHROMATIC_SHARPS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const CHROMATIC_FLATS = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const MAJOR_SCALE_INTERVALS = [0, 2, 4, 5, 7, 9, 11];
    const FLAT_KEYS = new Set(['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb']);

    function getNoteIndex(note) {
      let idx = CHROMATIC_SHARPS.indexOf(note);
      if (idx === -1) idx = CHROMATIC_FLATS.indexOf(note);
      return idx;
    }

    function getNoteAtIndex(index, preferFlats) {
      const normalizedIndex = ((index % 12) + 12) % 12;
      return preferFlats ? CHROMATIC_FLATS[normalizedIndex] : CHROMATIC_SHARPS[normalizedIndex];
    }

    function getMajorScale(keyRoot) {
      const rootIndex = getNoteIndex(keyRoot);
      if (rootIndex === -1) return null;
      const preferFlats = FLAT_KEYS.has(keyRoot);
      return MAJOR_SCALE_INTERVALS.map(interval => getNoteAtIndex(rootIndex + interval, preferFlats));
    }

    function numberToLetter(chordStr, key) {
      // Handle chromatic prefix (b7, #4, etc.)
      const chromaticMatch = chordStr.match(/^([#b])([1-7])(.*)$/);
      if (chromaticMatch) {
        const [, alteration, degreeStr, rest] = chromaticMatch;
        const degree = parseInt(degreeStr, 10);
        const scale = getMajorScale(key);
        if (!scale) return chordStr;

        const baseNote = scale[degree - 1];
        const baseIndex = getNoteIndex(baseNote);
        let targetIndex = baseIndex;
        if (alteration === '#') targetIndex = (baseIndex + 1) % 12;
        else if (alteration === 'b') targetIndex = (baseIndex + 11) % 12;

        const root = getNoteAtIndex(targetIndex, FLAT_KEYS.has(key));
        return root + rest;
      }

      // Parse regular number chord
      const match = chordStr.match(/^([1-7])(.*)$/);
      if (!match) return chordStr;

      const [, degreeStr, quality] = match;
      const degree = parseInt(degreeStr, 10);
      const scale = getMajorScale(key);
      if (!scale) return chordStr;

      const root = scale[degree - 1];

      // Handle slash chord bass note
      const slashMatch = quality.match(/^([^/]*)\/([#b]?[1-7])$/);
      if (slashMatch) {
        const [, chordQuality, bassNum] = slashMatch;
        const bassDegree = parseInt(bassNum.replace(/[#b]/, ''), 10);
        let bassNote = scale[bassDegree - 1];

        // Handle chromatic bass
        if (bassNum.startsWith('#')) {
          const idx = getNoteIndex(bassNote);
          bassNote = getNoteAtIndex((idx + 1) % 12, FLAT_KEYS.has(key));
        } else if (bassNum.startsWith('b')) {
          const idx = getNoteIndex(bassNote);
          bassNote = getNoteAtIndex((idx + 11) % 12, FLAT_KEYS.has(key));
        }

        return root + chordQuality + '/' + bassNote;
      }

      return root + quality;
    }

    function convertChordToLetter(chord, key) {
      if (!chord.isNumber) return chord;

      const fullChord = chord.root + (chord.quality || '') + (chord.bass ? '/' + chord.bass : '');
      const converted = numberToLetter(fullChord, key);

      // Re-parse the converted chord
      const letterMatch = converted.match(/^([A-G][#b]?)(.*?)(?:\/([A-G][#b]?))?$/);
      if (!letterMatch) return chord;

      const [, root, quality, bass] = letterMatch;
      return {
        root,
        quality: quality || undefined,
        bass: bass || undefined,
        isNumber: false
      };
    }

    // Render key control
    const renderKeySelect = document.getElementById('render-key');

    renderKeySelect.addEventListener('change', () => {
      render();
    });

    // Override render to apply key conversion
    const originalRender = render;
    render = function() {
      try {
        errorEl.style.display = 'none';
        const input = inputEl.value;
        let song = parseChordPro(input);

        const selectedKey = renderKeySelect.value;

        // Convert to letter notation if a key is selected (not "numbers")
        if (selectedKey !== 'numbers') {
          song = convertSongToLetters(song, selectedKey);
          song.key = selectedKey;
        }

        renderer.loadSong(song);
        currentPage = 0;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      } catch (e) {
        errorEl.textContent = 'Error: ' + e.message;
        errorEl.style.display = 'block';
        console.error(e);
      }
    };

    function convertSongToLetters(song, key) {
      return {
        ...song,
        sections: song.sections.map(section => ({
          ...section,
          lines: section.lines.map(line => ({
            ...line,
            chords: line.chords.map(cp => ({
              ...cp,
              chord: convertChordToLetter(cp.chord, key)
            }))
          }))
        }))
      };
    }

    // Initial render
    render();
    updateButtonStates();
  </script>
</body>
</html>
