<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ChartMaker Renderer Demo</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }

    h1 {
      margin: 0 0 20px 0;
      color: #333;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .controls {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .controls label {
      display: block;
      margin-bottom: 10px;
      font-weight: 500;
    }

    .controls textarea {
      width: 100%;
      height: 300px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
    }

    .controls select {
      padding: 10px 14px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      min-width: 140px;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 36px;
    }

    .controls select:hover {
      border-color: #999;
    }

    .controls select:focus {
      outline: none;
      border-color: #4a4a4a;
      box-shadow: 0 0 0 2px rgba(74, 74, 74, 0.2);
    }

    .toolbar {
      display: flex;
      gap: 12px;
      margin-bottom: 15px;
    }

    .page-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .page-controls button {
      padding: 8px 16px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .page-controls button:hover:not(:disabled) {
      border-color: #999;
      background: #f5f5f5;
    }

    .page-controls button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .page-controls span {
      font-size: 14px;
      color: #666;
    }

    .preview-container {
      background: #666;
      padding: 20px;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    #chart-canvas {
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .error {
      color: #d32f2f;
      background: #ffebee;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      display: none;
    }

    .info {
      color: #1976d2;
      background: #e3f2fd;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ChartMaker Renderer Demo</h1>

    <div class="controls">
      <div class="toolbar">
        <select id="library-select">
          <option value="">Custom Input</option>
          <option value="living-hope">Living Hope</option>
          <option value="no-longer-slaves">No Longer Slaves</option>
          <option value="i-thank-god">I Thank God</option>
        </select>
        <select id="render-key">
          <option value="numbers">Numbers</option>
          <option value="C">Key of C</option>
          <option value="Db">Key of Db</option>
          <option value="D">Key of D</option>
          <option value="Eb">Key of Eb</option>
          <option value="E">Key of E</option>
          <option value="F">Key of F</option>
          <option value="Gb">Key of Gb</option>
          <option value="G">Key of G</option>
          <option value="Ab">Key of Ab</option>
          <option value="A">Key of A</option>
          <option value="Bb">Key of Bb</option>
          <option value="B">Key of B</option>
        </select>
      </div>
      <label>
        Chart input:
        <textarea id="input">{title: Living Hope}
{artist: Phil Wickham}
{key: Eb}
{tempo: 72}
{time: 4/4}

{section: Intro}
{dynamics: Acoustic Guitar, Piano & Pad}
[1] [4sus2] [1] [4sus2]

{section: Verse 1}
How great the [1]chasm
That lay between [5sus4]us
How high the [42]mountain
[6m7]I could not [5sus4]climb
In desperation [1]I turned to Heaven [5sus4]
And spoke Your name [4sus2]Into [5sus4]the night [1]

{section: Pre Chorus 1}
Then through the darkness [4sus2]
Your loving kindness [1]
Tore through the shadows [6m7]of my soul [5sus4]
The work is finished [1]the end is written [5sus4]
Jesus Christ [4sus2]my living [5sus4]hope

{section: Interlude}
[1] [4]

{section: Verse 2}
{dynamics: Add Bass & soft Drum groove}
Who could imagine [1]
So great a mercy [5sus4]
What heart could fathom [42]
Such [6m7]boundless grace [5sus4]
The God of ages [1]
Stepped down from glory [5sus4]
To wear my sin [42]And bear [5sus4]my shame [1]

{section: Chorus}
{dynamics: Increase Dynamics}
Hallelu - [42]jah [1]
Praise the One [5add4]who set me free [6m7]
Hallelu - [42]jah [1]
Death has lost [5add4]its grip on me [6m7]
You [6m7/5]have broken [42]every chain [1]
There's salvation [5add4]in Your name [6m7]
Jesus [6m7/5]Christ [42]my living [5sus4]hope [1]

{section: Tag}
Jesus Yours [42]is the victory [5add4]

{section: Ending}
[1]</textarea>
      </label>
      <div class="error" id="error"></div>
      <div class="info">
        Tip: This demo uses the browser's Canvas API. The Lato font family will be used if available, otherwise system fonts.
      </div>
    </div>

    <div class="page-controls">
      <button id="prev-btn" disabled>&larr; Previous</button>
      <span id="page-info">Page 1 of 1</span>
      <button id="next-btn" disabled>Next &rarr;</button>
    </div>

    <div class="preview-container">
      <canvas id="chart-canvas"></canvas>
    </div>
  </div>

  <script type="module">
    // Import from the compiled dist folder
    // Note: For this to work, you need to serve this from a local server
    // or use a bundler. For simplicity, we'll inline the necessary code.

    // Sample Song data structure (matches the parsed output)
    const SECTION_ABBREVIATIONS = {
      intro: 'I',
      verse: 'V',
      prechorus: 'Pr',
      chorus: 'C',
      bridge: 'B',
      outro: 'O',
      tag: 'Tg',
      instrumental: 'Inst',
      interlude: 'It',
      vamp: 'Vp',
      turnaround: 'T',
      ending: 'E',
      custom: ''
    };

    const SECTION_NAMES = {
      intro: 'INTRO',
      verse: 'VERSE',
      prechorus: 'PRE CHORUS',
      chorus: 'CHORUS',
      bridge: 'BRIDGE',
      outro: 'OUTRO',
      tag: 'TAG',
      instrumental: 'INSTRUMENTAL',
      interlude: 'INTERLUDE',
      vamp: 'VAMP',
      turnaround: 'TURNAROUND',
      ending: 'ENDING',
      custom: ''
    };

    // Default render configuration
    const DEFAULT_CONFIG = {
      page: { width: 816, height: 1056 },
      margins: { top: 40, right: 40, bottom: 60, left: 40 },
      columnGap: 30,
      fonts: {
        title: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 28, weight: 'bold', lineHeight: 1.2 },
        artist: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 14, weight: 'normal', lineHeight: 1.4 },
        metadata: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 12, weight: 'normal', lineHeight: 1.4 },
        sectionName: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 13, weight: 'bold', lineHeight: 1.4 },
        chordRoot: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 14, weight: 'bold', lineHeight: 1.3 },
        chordQuality: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 10, weight: 'normal', lineHeight: 1.3 },
        lyrics: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 13, weight: 'normal', lineHeight: 1.4 },
        dynamics: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 11, weight: '300', lineHeight: 1.4 },
        roadmapBadge: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 10, weight: 'normal', lineHeight: 1 },
        pageNumber: { family: 'Lato, -apple-system, BlinkMacSystemFont, sans-serif', size: 12, weight: 'normal', lineHeight: 1.4 }
      },
      colors: {
        background: '#ffffff',
        text: '#1a1a1a',
        textSecondary: '#333333',
        textMuted: '#888888',
        badgeFill: '#4a4a4a',
        badgeText: '#ffffff',
        rule: '#cccccc',
        roadmapInactive: '#666666'
      },
      badgeRadius: 11,
      roadmapBadgeRadius: 12,
      spacing: {
        afterHeader: 15,
        afterRoadmap: 20,
        betweenSections: 18,
        betweenLines: 4,
        chordToLyric: 2,
        sectionHeaderHeight: 28,
        roadmapHeight: 36
      }
    };

    // Simple ChordPro parser for demo
    function parseChordPro(input) {
      const song = {
        title: 'Untitled',
        artist: 'Unknown',
        key: 'C',
        tempo: null,
        timeSignature: '4/4',
        sections: []
      };

      const lines = input.split(/\r?\n/);
      let currentSection = null;
      let pendingDynamics = null;

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        // Parse directives
        const directiveMatch = trimmed.match(/^\{(\w+):\s*(.+?)\}$/);
        if (directiveMatch) {
          const [, directive, value] = directiveMatch;
          switch (directive.toLowerCase()) {
            case 'title':
            case 't':
              song.title = value;
              break;
            case 'artist':
            case 'a':
              song.artist = value;
              break;
            case 'key':
            case 'k':
              song.key = value;
              break;
            case 'tempo':
              song.tempo = parseInt(value, 10);
              break;
            case 'time':
              song.timeSignature = value;
              break;
            case 'section':
              // Start new section
              const sectionInfo = parseSectionName(value);
              currentSection = {
                type: sectionInfo.type,
                number: sectionInfo.number,
                label: sectionInfo.label,
                dynamics: pendingDynamics,
                lines: []
              };
              pendingDynamics = null;
              song.sections.push(currentSection);
              break;
            case 'dynamics':
              if (currentSection) {
                currentSection.dynamics = value;
              } else {
                pendingDynamics = value;
              }
              break;
          }
          continue;
        }

        // Parse chord/lyric lines
        if (currentSection && trimmed.includes('[')) {
          const parsedLine = parseChordLine(trimmed);
          currentSection.lines.push(parsedLine);
        } else if (currentSection && !trimmed.startsWith('{')) {
          // Plain lyrics without chords
          currentSection.lines.push({ lyrics: trimmed, chords: [] });
        }
      }

      return song;
    }

    function parseSectionName(value) {
      const lower = value.toLowerCase().replace(/\s+/g, '');

      // Check for numbered sections
      const numberMatch = value.match(/(\d+)$/);
      const number = numberMatch ? parseInt(numberMatch[1], 10) : undefined;
      const baseName = value.replace(/\s*\d+$/, '').toLowerCase().replace(/\s+/g, '');

      const typeMap = {
        'intro': 'intro',
        'verse': 'verse',
        'prechorus': 'prechorus',
        'pre-chorus': 'prechorus',
        'chorus': 'chorus',
        'bridge': 'bridge',
        'outro': 'outro',
        'tag': 'tag',
        'instrumental': 'instrumental',
        'interlude': 'interlude',
        'vamp': 'vamp',
        'turnaround': 'turnaround',
        'ending': 'ending'
      };

      return {
        type: typeMap[baseName] || 'custom',
        number,
        label: typeMap[baseName] ? null : value
      };
    }

    function parseChordLine(line) {
      const chords = [];
      let lyrics = '';
      let position = 0;
      let i = 0;

      while (i < line.length) {
        if (line[i] === '[') {
          const end = line.indexOf(']', i);
          if (end > i) {
            const chordStr = line.substring(i + 1, end);
            const chord = parseChordString(chordStr);
            chords.push({ chord, position });
            i = end + 1;
            continue;
          }
        }
        lyrics += line[i];
        position++;
        i++;
      }

      return { lyrics: lyrics.trim() || undefined, chords };
    }

    function parseChordString(str) {
      // First check for number chords (Nashville notation): 1, 2, 42, 6m7, 1/3, etc.
      const numberMatch = str.match(/^([#b]?[1-7])(.*?)(?:\/([#b]?[1-7]))?$/);
      if (numberMatch) {
        const [, root, quality, bass] = numberMatch;
        return {
          root,
          quality: quality || undefined,
          bass: bass || undefined,
          isNumber: true
        };
      }

      // Match letter chords: root, quality, and optional bass note
      const match = str.match(/^([A-G][#b]?)(.*?)(?:\/([A-G][#b]?))?$/);
      if (!match) return { root: str };

      const [, root, quality, bass] = match;
      return {
        root,
        quality: quality || undefined,
        bass: bass || undefined,
        isNumber: false
      };
    }

    // Renderer implementation
    class ChartRenderer {
      constructor(config = DEFAULT_CONFIG) {
        this.config = config;
        this.song = null;
        this.layout = null;
        this.pixelRatio = window.devicePixelRatio || 1;
      }

      loadSong(song) {
        this.song = song;
        this.layout = this.calculateLayout();
      }

      calculateLayout() {
        if (!this.song) return null;

        const contentWidth = this.config.page.width - this.config.margins.left - this.config.margins.right;
        const columnWidth = (contentWidth - this.config.columnGap) / 2;

        const headerHeight =
          this.config.fonts.title.size * this.config.fonts.title.lineHeight +
          this.config.fonts.artist.size * this.config.fonts.artist.lineHeight +
          this.config.spacing.afterHeader;

        const roadmapHeight = this.config.spacing.roadmapHeight + this.config.spacing.afterRoadmap;
        const contentStartY = this.config.margins.top + headerHeight + roadmapHeight;
        const columnHeight = this.config.page.height - contentStartY - this.config.margins.bottom;

        const sections = [];
        let page = 0;
        let column = 0;
        let columnY = 0;

        const advanceColumn = () => {
          if (column === 0) {
            column = 1;
            columnY = 0;
          } else {
            page++;
            column = 0;
            columnY = 0;
          }
        };

        for (let i = 0; i < this.song.sections.length; i++) {
          const section = this.song.sections[i];
          const sectionHeight = this.calculateSectionHeight(section);

          // If section doesn't fit and we're not at top, move to next column/page
          if (columnY > 0 && columnY + sectionHeight > columnHeight) {
            advanceColumn();
          }

          sections.push({
            sectionIndex: i,
            column,
            y: columnY,
            height: sectionHeight,
            page
          });

          columnY += sectionHeight + this.config.spacing.betweenSections;

          // If exceeded column height, next section goes to new column
          if (columnY >= columnHeight) {
            advanceColumn();
          }
        }

        return {
          pageCount: page + 1,
          sections,
          columnWidth,
          columnHeight,
          contentStartY,
          column1X: this.config.margins.left,
          column2X: this.config.margins.left + columnWidth + this.config.columnGap
        };
      }

      calculateSectionHeight(section) {
        let height = this.config.badgeRadius * 2 + 6;

        if (section.dynamics) {
          height += 4;
        }

        for (let i = 0; i < section.lines.length; i++) {
          const line = section.lines[i];
          const hasChords = line.chords && line.chords.length > 0;
          const hasLyrics = line.lyrics && line.lyrics.trim().length > 0;
          const isChordOnly = hasChords && !hasLyrics;

          if (isChordOnly) {
            height += this.config.fonts.chordRoot.size * this.config.fonts.chordRoot.lineHeight;
          } else if (hasChords && hasLyrics) {
            height += this.config.fonts.chordRoot.size * this.config.fonts.chordRoot.lineHeight;
            height += this.config.spacing.chordToLyric;
            height += this.config.fonts.lyrics.size * this.config.fonts.lyrics.lineHeight;
          } else if (hasLyrics) {
            height += this.config.fonts.lyrics.size * this.config.fonts.lyrics.lineHeight;
          }

          if (i < section.lines.length - 1) {
            height += this.config.spacing.betweenLines;
          }
        }

        return height;
      }

      renderPage(canvas, pageIndex) {
        if (!this.song || !this.layout) return;

        const { width, height } = this.config.page;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        canvas.width = width * this.pixelRatio;
        canvas.height = height * this.pixelRatio;

        const ctx = canvas.getContext('2d');
        ctx.scale(this.pixelRatio, this.pixelRatio);

        // Clear background
        ctx.fillStyle = this.config.colors.background;
        ctx.fillRect(0, 0, width, height);

        // Render header
        let y = this.renderHeader(ctx, pageIndex);

        // Render roadmap (first page only)
        if (pageIndex === 0) {
          y = this.renderRoadmap(ctx, y);
          y += this.config.spacing.afterRoadmap;
        }

        // Render sections
        const pageSections = this.layout.sections.filter(s => s.page === pageIndex);

        for (const layoutSection of pageSections) {
          const section = this.song.sections[layoutSection.sectionIndex];
          const x = layoutSection.column === 0 ? this.layout.column1X : this.layout.column2X;
          const sectionY = this.layout.contentStartY + layoutSection.y;

          this.renderSection(ctx, section, x, sectionY, this.layout.columnWidth);
        }
      }

      renderHeader(ctx, pageIndex) {
        const config = this.config;
        let y = config.margins.top;

        if (pageIndex === 0) {
          // Title
          ctx.font = `${config.fonts.title.weight} ${config.fonts.title.size}px ${config.fonts.title.family}`;
          ctx.fillStyle = config.colors.text;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(this.song.title, config.margins.left, y);

          // Page number
          ctx.font = `${config.fonts.pageNumber.weight} ${config.fonts.pageNumber.size}px ${config.fonts.pageNumber.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'right';
          ctx.fillText(`Page: ${pageIndex + 1}/${this.layout.pageCount}`, config.page.width - config.margins.right, y);

          y += config.fonts.title.size * config.fonts.title.lineHeight;

          // Artist
          ctx.font = `${config.fonts.artist.weight} ${config.fonts.artist.size}px ${config.fonts.artist.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'left';
          ctx.fillText(this.song.artist, config.margins.left, y);

          // Metadata
          ctx.font = `${config.fonts.metadata.weight} ${config.fonts.metadata.size}px ${config.fonts.metadata.family}`;
          ctx.textAlign = 'right';
          const meta = [];
          if (this.song.key) meta.push(`Key: ${this.song.key}`);
          if (this.song.tempo) meta.push(`Tempo: ${this.song.tempo}`);
          if (this.song.timeSignature) meta.push(`Time: ${this.song.timeSignature}`);
          ctx.fillText(meta.join('  '), config.page.width - config.margins.right, y);

          y += config.fonts.artist.size * config.fonts.artist.lineHeight;
        } else {
          // Compact header
          ctx.font = `bold ${config.fonts.sectionName.size + 4}px ${config.fonts.title.family}`;
          ctx.fillStyle = config.colors.text;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(this.song.title, config.margins.left, y);

          ctx.font = `${config.fonts.pageNumber.weight} ${config.fonts.pageNumber.size}px ${config.fonts.pageNumber.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'right';
          ctx.fillText(`Page: ${pageIndex + 1}/${this.layout.pageCount}`, config.page.width - config.margins.right, y);

          y += (config.fonts.sectionName.size + 4) * 1.4;
        }

        return y + config.spacing.afterHeader;
      }

      renderRoadmap(ctx, y) {
        const config = this.config;
        const entries = this.generateRoadmap();
        let x = config.margins.left;

        for (const entry of entries) {
          const radius = config.roadmapBadgeRadius;
          const centerY = y + radius;

          // Draw circle (outline for roadmap)
          ctx.beginPath();
          ctx.arc(x + radius, centerY, radius, 0, Math.PI * 2);
          ctx.strokeStyle = config.colors.roadmapInactive;
          ctx.lineWidth = 1.5;
          ctx.stroke();

          // Draw abbreviation
          ctx.font = `${config.fonts.roadmapBadge.weight} ${config.fonts.roadmapBadge.size}px ${config.fonts.roadmapBadge.family}`;
          ctx.fillStyle = config.colors.roadmapInactive;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(entry.abbreviation, x + radius, centerY);

          // Superscript for repeat count
          if (entry.repeatCount > 1) {
            const superSize = config.fonts.roadmapBadge.size * 0.75;
            ctx.font = `${config.fonts.roadmapBadge.weight} ${superSize}px ${config.fonts.roadmapBadge.family}`;
            ctx.fillStyle = config.colors.text;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(entry.repeatCount.toString(), x + radius * 2 - 2, y - 2);
          }

          x += radius * 2 + 8;
        }

        return y + config.spacing.roadmapHeight;
      }

      generateRoadmap() {
        const entries = [];
        let currentAbbr = '';
        let currentCount = 0;

        for (const section of this.song.sections) {
          let abbr = SECTION_ABBREVIATIONS[section.type] || '';
          if (section.number) abbr += section.number;
          if (section.type === 'custom' && section.label) {
            abbr = section.label.substring(0, 2).toUpperCase();
          }

          if (abbr === currentAbbr) {
            currentCount++;
          } else {
            if (currentAbbr) {
              entries.push({ abbreviation: currentAbbr, repeatCount: currentCount > 1 ? currentCount : null });
            }
            currentAbbr = abbr;
            currentCount = 1;
          }
        }

        if (currentAbbr) {
          entries.push({ abbreviation: currentAbbr, repeatCount: currentCount > 1 ? currentCount : null });
        }

        return entries;
      }

      renderSection(ctx, section, x, y, width) {
        const config = this.config;
        let currentY = y;

        // Render badge
        const abbr = this.getSectionAbbreviation(section);
        const radius = config.badgeRadius;

        ctx.beginPath();
        ctx.arc(x + radius, y + radius, radius, 0, Math.PI * 2);
        ctx.fillStyle = config.colors.badgeFill;
        ctx.fill();

        ctx.font = `${config.fonts.roadmapBadge.weight} ${config.fonts.roadmapBadge.size}px ${config.fonts.roadmapBadge.family}`;
        ctx.fillStyle = config.colors.badgeText;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(abbr, x + radius, y + radius);

        // Render section name
        const displayName = this.getSectionDisplayName(section);
        const nameX = x + radius * 2 + 8;
        const nameY = y + radius + 4;

        ctx.font = `${config.fonts.sectionName.weight} ${config.fonts.sectionName.size}px ${config.fonts.sectionName.family}`;
        ctx.fillStyle = config.colors.text;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(displayName, nameX, nameY);

        const nameWidth = ctx.measureText(displayName).width;

        // Horizontal rule
        const ruleStartX = nameX + nameWidth + 10;
        const ruleEndX = x + width;

        if (ruleEndX > ruleStartX + 20) {
          ctx.beginPath();
          ctx.moveTo(ruleStartX, nameY);
          ctx.lineTo(ruleEndX, nameY);
          ctx.strokeStyle = config.colors.rule;
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        // Dynamics
        if (section.dynamics) {
          ctx.font = `${config.fonts.dynamics.weight} ${config.fonts.dynamics.size}px ${config.fonts.dynamics.family}`;
          ctx.fillStyle = config.colors.textMuted;
          ctx.textAlign = 'right';
          ctx.textBaseline = 'top';
          ctx.fillText(section.dynamics, x + width, y + 4);
        }

        currentY += radius * 2 + 6;
        if (section.dynamics) currentY += 4;

        // Render lines
        for (let i = 0; i < section.lines.length; i++) {
          const line = section.lines[i];
          currentY += this.renderLine(ctx, line, x, currentY, width);

          if (i < section.lines.length - 1) {
            currentY += config.spacing.betweenLines;
          }
        }

        return currentY - y;
      }

      renderLine(ctx, line, x, y, width) {
        const config = this.config;
        let currentY = y;
        const hasChords = line.chords && line.chords.length > 0;
        const hasLyrics = line.lyrics && line.lyrics.trim().length > 0;
        const isChordOnly = hasChords && !hasLyrics;

        if (isChordOnly) {
          // Chord-only line
          const chordY = currentY + config.fonts.chordRoot.size;
          this.renderChordRow(ctx, line.chords.map(c => c.chord), x, chordY, width);
          currentY += config.fonts.chordRoot.size * config.fonts.chordRoot.lineHeight;

        } else if (hasChords && hasLyrics) {
          // Chords above lyrics - renders both with stretched spacing
          const chordY = currentY + config.fonts.chordRoot.size;
          currentY += config.fonts.chordRoot.size * config.fonts.chordRoot.lineHeight;
          currentY += config.spacing.chordToLyric;
          const lyricY = currentY;

          this.renderChordsAboveLyrics(ctx, line.chords, line.lyrics, x, chordY, lyricY);
          currentY += config.fonts.lyrics.size * config.fonts.lyrics.lineHeight;

        } else if (hasLyrics) {
          ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;
          ctx.fillStyle = config.colors.textSecondary;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(line.lyrics, x, currentY);
          currentY += config.fonts.lyrics.size * config.fonts.lyrics.lineHeight;
        }

        return currentY - y;
      }

      renderChord(ctx, chord, x, y) {
        const config = this.config;
        let currentX = x;

        ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
        ctx.fillStyle = config.colors.text;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(chord.root, currentX, y);
        currentX += ctx.measureText(chord.root).width;

        if (chord.quality) {
          ctx.font = `${config.fonts.chordQuality.weight} ${config.fonts.chordQuality.size}px ${config.fonts.chordQuality.family}`;
          const qualityY = y - (config.fonts.chordRoot.size * 0.25);
          ctx.fillText(chord.quality, currentX, qualityY);
          currentX += ctx.measureText(chord.quality).width;
        }

        if (chord.bass) {
          ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
          ctx.fillText('/' + chord.bass, currentX, y);
          currentX += ctx.measureText('/' + chord.bass).width;
        }

        return currentX - x;
      }

      measureChordWidth(ctx, chord) {
        const config = this.config;
        let width = 0;

        ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
        width += ctx.measureText(chord.root).width;

        if (chord.quality) {
          ctx.font = `${config.fonts.chordQuality.weight} ${config.fonts.chordQuality.size}px ${config.fonts.chordQuality.family}`;
          width += ctx.measureText(chord.quality).width;
        }

        if (chord.bass) {
          ctx.font = `${config.fonts.chordRoot.weight} ${config.fonts.chordRoot.size}px ${config.fonts.chordRoot.family}`;
          width += ctx.measureText('/' + chord.bass).width;
        }

        return width;
      }

      renderChordRow(ctx, chords, x, y, width) {
        if (chords.length === 0) return;
        if (chords.length === 1) {
          this.renderChord(ctx, chords[0], x, y);
          return;
        }

        const chordWidths = chords.map(c => this.measureChordWidth(ctx, c));
        const totalWidth = chordWidths.reduce((a, b) => a + b, 0);
        const spacing = (width - totalWidth) / chords.length;

        let currentX = x;
        for (let i = 0; i < chords.length; i++) {
          this.renderChord(ctx, chords[i], currentX, y);
          currentX += chordWidths[i] + spacing;
        }
      }

      renderChordsAboveLyrics(ctx, chordPositions, lyrics, x, chordY, lyricY) {
        const config = this.config;

        // Sort by position
        const sorted = [...chordPositions].sort((a, b) => a.position - b.position);

        ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;

        const minGap = 8;
        const positions = [];
        const segments = [];
        let currentX = x;

        // Calculate positions with overlap prevention
        for (let i = 0; i < sorted.length; i++) {
          const cp = sorted[i];
          const prevPos = i === 0 ? 0 : sorted[i - 1].position;
          const segmentText = lyrics.substring(prevPos, cp.position);

          if (segmentText) {
            segments.push({ text: segmentText, xPos: currentX });
            currentX += ctx.measureText(segmentText).width;
          }

          const chordWidth = this.measureChordWidth(ctx, cp.chord);

          // Check overlap with previous chord
          if (positions.length > 0) {
            const prev = positions[positions.length - 1];
            const minX = prev.xPos + prev.width + minGap;
            if (currentX < minX) {
              currentX = minX;
            }
          }

          positions.push({ chord: cp.chord, xPos: currentX, width: chordWidth });
        }

        // Add remaining lyrics
        if (sorted.length > 0) {
          const lastPos = sorted[sorted.length - 1].position;
          const remaining = lyrics.substring(lastPos);
          if (remaining) {
            segments.push({ text: remaining, xPos: currentX });
          }
        }

        // Render chords
        for (const p of positions) {
          this.renderChord(ctx, p.chord, p.xPos, chordY);
        }

        // Render stretched lyrics
        ctx.font = `${config.fonts.lyrics.weight} ${config.fonts.lyrics.size}px ${config.fonts.lyrics.family}`;
        ctx.fillStyle = config.colors.textSecondary;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';

        for (const seg of segments) {
          ctx.fillText(seg.text, seg.xPos, lyricY);
        }
      }

      getSectionAbbreviation(section) {
        let abbr = SECTION_ABBREVIATIONS[section.type] || '';
        if (section.number) abbr += section.number;
        if (section.type === 'custom' && section.label) {
          abbr = section.label.substring(0, 2).toUpperCase();
        }
        return abbr;
      }

      getSectionDisplayName(section) {
        if (section.label) return section.label.toUpperCase();
        let name = SECTION_NAMES[section.type] || section.type.toUpperCase();
        if (section.number) name += ' ' + section.number;
        return name;
      }
    }

    // Demo app
    const inputEl = document.getElementById('input');
    const canvas = document.getElementById('chart-canvas');
    const errorEl = document.getElementById('error');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const pageInfoEl = document.getElementById('page-info');

    let renderer = new ChartRenderer();
    let currentPage = 0;

    function updatePageControls() {
      const pageCount = renderer.layout ? renderer.layout.pageCount : 1;
      pageInfoEl.textContent = `Page ${currentPage + 1} of ${pageCount}`;
      prevBtn.disabled = currentPage === 0;
      nextBtn.disabled = currentPage >= pageCount - 1;
    }

    function render() {
      try {
        errorEl.style.display = 'none';
        const input = inputEl.value;
        const song = parseChordPro(input);
        renderer.loadSong(song);
        currentPage = 0;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      } catch (e) {
        errorEl.textContent = 'Error: ' + e.message;
        errorEl.style.display = 'block';
        console.error(e);
      }
    }

    // Realtime rendering on textarea input
    inputEl.addEventListener('input', render);

    prevBtn.addEventListener('click', () => {
      if (currentPage > 0) {
        currentPage--;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      }
    });

    nextBtn.addEventListener('click', () => {
      if (renderer.layout && currentPage < renderer.layout.pageCount - 1) {
        currentPage++;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      }
    });

    // Library chart data (stored in Nashville Number notation)
    const LIBRARY_CHARTS = {
      'living-hope': `{title: Living Hope}
{artist: Phil Wickham}
{key: Eb}
{tempo: 72}
{time: 4/4}

{section: Intro}
{dynamics: Acoustic Guitar, Piano & Pad}
[1] [4sus2] [1] [4sus2]

{section: Verse 1}
How great the [1]chasm
That lay between [5sus4]us
How high the [42]mountain
[6m7]I could not [5sus4]climb
In desperation [1]I turned to Heaven [5sus4]
And spoke Your name [4sus2]Into [5sus4]the night [1]

{section: Pre Chorus 1}
Then through the darkness [4sus2]
Your loving kindness [1]
Tore through the shadows [6m7]of my soul [5sus4]
The work is finished [1]the end is written [5sus4]
Jesus Christ [4sus2]my living [5sus4]hope

{section: Interlude}
[1] [4]

{section: Verse 2}
{dynamics: Add Bass & soft Drum groove}
Who could imagine [1]
So great a mercy [5sus4]
What heart could fathom [42]
Such [6m7]boundless grace [5sus4]
The God of ages [1]
Stepped down from glory [5sus4]
To wear my sin [42]And bear [5sus4]my shame [1]

{section: Pre Chorus 2}
{dynamics: Increase dynamics slightly}
The Cross has spoken [4sus2]I am forgiven [1]
The King of kings [6m7]calls me His own [5]
Beautiful Savior [1]I'm Yours forever [5sus4]
Jesus Christ [4sus2]my living [5sus4]hope [1]

{section: Chorus}
{dynamics: Increase Dynamics}
Hallelu - [42]jah [1]
Praise the One [5add4]who set me free [6m7]
Hallelu - [42]jah [1]
Death has lost [5add4]its grip on me [6m7]
You [6m7/5]have broken [42]every chain [1]
There's salvation [5add4]in Your name [6m7]
Jesus [6m7/5]Christ [42]my living [5sus4]hope [1]

{section: Tag}
Jesus Yours [42]is the victory [5add4]

{section: Ending}
[1]`,

      'no-longer-slaves': `{title: No Longer Slaves}
{artist: Bethel Music}
{key: Bb}
{tempo: 74}
{time: 4/4}

{section: Verse 1}
{dynamics: Acoustic Guitar & Piano}
You unravel [1]me with a melody
You surround [4]me with [5]a song [1]
Of deliverance [1]from my enemies
'Til all [4]my fears [5]are gone [1]

{section: Chorus}
{dynamics: Add Strings}
I'm no longer [4]a slave [5]to fear [1]
I [6m]am a child [5]of God [1]
I'm no longer [4]a slave [5]to fear [1]
I [6m]am a child [5]of God

{section: Interlude}
{dynamics: Add Bass, Keys & Light Drums}
[6m] [5] [1] [4]
[6m] [5] [1] [4]

{section: Verse 2}
{dynamics: Add Electric Guitar, Light Tom groove}
From my mother's [1]womb
You have chosen [3m]me
Love has [4]called [5]my name [1]
I've been born [1]again into Your family [3m]
Your blood [4]flows through [5]my veins [1]

{section: Chorus}
{dynamics: Increase dynamics slightly}
I'm no longer [4]a slave [5]to fear [1]
I [6m]am a child [5]of God [1]
I'm no longer [4]a slave [5]to fear [1]
I [6m]am a child [5]of God

{section: Bridge}
{dynamics: All in, full Groove}
You [6m]split the sea [5]
So I could walk [1]right through [4]it
My [6m]fears were drowned [5]
In perfect love [1] [4]
You [6m]rescued me [5]
And I will stand [1]and sing [3m]
I am [4]a child [5]of God [1]

{section: Tag}
I am [4]a child [5]of God [1]

{section: Ending}
[1]`,

      'i-thank-god': `{title: I Thank God}
{artist: Maverick City Music}
{key: Db}
{tempo: 130}
{time: 4/4}

{section: Intro}
{dynamics: Acoustic Guitar driving, Tom groove}
[1] [1sus4] [1] [1sus4]
[1] [1sus4] [1] [1sus4]

{section: Verse 1}
Wandering [1]into the night
Wanting a place to hide
This weary soul [42]
This bag of bones [1] [4/1]

{section: Verse 2}
I [1]tried with all my might
But I just can't win the fight
I'm slowly drifting [42]a vagabond [1]

{section: Pre Chorus 1}
{dynamics: Build to Chorus}
And just [5]when I ran out [6m7]of road
I met [4]a man I didn't [1]know
And he [5]told me
That I [1/3]was not alone [4]

{section: Chorus}
{dynamics: Bigger}
You picked [1]me up turned [2m7]me around
Placed [1/3]my feet on solid [42]ground
I thank the Master [6m7]
I thank the Savior [42]
Because He healed [1]my heart
He changed [2m7]my name
Forever [1/3]free I'm not [42]the same
I thank the Master [6m7]
I thank the Savior [42]
I thank God

{section: Bridge 1}
{dynamics: Slight breakdown}
Hell [1]lost another one
I am free
I am free
I am free

{section: Bridge 2}
{dynamics: Band building}
Hell [5]lost another one
I [6m7]am free
I [42]am free
I [1]am free

{section: Ending}
[1]`
    };

    // Number to Letter conversion utilities
    const CHROMATIC_SHARPS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const CHROMATIC_FLATS = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const MAJOR_SCALE_INTERVALS = [0, 2, 4, 5, 7, 9, 11];
    const FLAT_KEYS = new Set(['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb']);

    function getNoteIndex(note) {
      let idx = CHROMATIC_SHARPS.indexOf(note);
      if (idx === -1) idx = CHROMATIC_FLATS.indexOf(note);
      return idx;
    }

    function getNoteAtIndex(index, preferFlats) {
      const normalizedIndex = ((index % 12) + 12) % 12;
      return preferFlats ? CHROMATIC_FLATS[normalizedIndex] : CHROMATIC_SHARPS[normalizedIndex];
    }

    function getMajorScale(keyRoot) {
      const rootIndex = getNoteIndex(keyRoot);
      if (rootIndex === -1) return null;
      const preferFlats = FLAT_KEYS.has(keyRoot);
      return MAJOR_SCALE_INTERVALS.map(interval => getNoteAtIndex(rootIndex + interval, preferFlats));
    }

    function numberToLetter(chordStr, key) {
      // Handle chromatic prefix (b7, #4, etc.)
      const chromaticMatch = chordStr.match(/^([#b])([1-7])(.*)$/);
      if (chromaticMatch) {
        const [, alteration, degreeStr, rest] = chromaticMatch;
        const degree = parseInt(degreeStr, 10);
        const scale = getMajorScale(key);
        if (!scale) return chordStr;

        const baseNote = scale[degree - 1];
        const baseIndex = getNoteIndex(baseNote);
        let targetIndex = baseIndex;
        if (alteration === '#') targetIndex = (baseIndex + 1) % 12;
        else if (alteration === 'b') targetIndex = (baseIndex + 11) % 12;

        const root = getNoteAtIndex(targetIndex, FLAT_KEYS.has(key));
        return root + rest;
      }

      // Parse regular number chord
      const match = chordStr.match(/^([1-7])(.*)$/);
      if (!match) return chordStr;

      const [, degreeStr, quality] = match;
      const degree = parseInt(degreeStr, 10);
      const scale = getMajorScale(key);
      if (!scale) return chordStr;

      const root = scale[degree - 1];

      // Handle slash chord bass note
      const slashMatch = quality.match(/^([^/]*)\/([#b]?[1-7])$/);
      if (slashMatch) {
        const [, chordQuality, bassNum] = slashMatch;
        const bassDegree = parseInt(bassNum.replace(/[#b]/, ''), 10);
        let bassNote = scale[bassDegree - 1];

        // Handle chromatic bass
        if (bassNum.startsWith('#')) {
          const idx = getNoteIndex(bassNote);
          bassNote = getNoteAtIndex((idx + 1) % 12, FLAT_KEYS.has(key));
        } else if (bassNum.startsWith('b')) {
          const idx = getNoteIndex(bassNote);
          bassNote = getNoteAtIndex((idx + 11) % 12, FLAT_KEYS.has(key));
        }

        return root + chordQuality + '/' + bassNote;
      }

      return root + quality;
    }

    function convertChordToLetter(chord, key) {
      if (!chord.isNumber) return chord;

      const fullChord = chord.root + (chord.quality || '') + (chord.bass ? '/' + chord.bass : '');
      const converted = numberToLetter(fullChord, key);

      // Re-parse the converted chord
      const letterMatch = converted.match(/^([A-G][#b]?)(.*?)(?:\/([A-G][#b]?))?$/);
      if (!letterMatch) return chord;

      const [, root, quality, bass] = letterMatch;
      return {
        root,
        quality: quality || undefined,
        bass: bass || undefined,
        isNumber: false
      };
    }

    // Library and render key controls
    const librarySelect = document.getElementById('library-select');
    const renderKeySelect = document.getElementById('render-key');

    librarySelect.addEventListener('change', () => {
      const chartId = librarySelect.value;
      if (chartId && LIBRARY_CHARTS[chartId]) {
        inputEl.value = LIBRARY_CHARTS[chartId];
        render();
      }
    });

    renderKeySelect.addEventListener('change', () => {
      render();
    });

    // Override render to apply key conversion
    const originalRender = render;
    render = function() {
      try {
        errorEl.style.display = 'none';
        const input = inputEl.value;
        let song = parseChordPro(input);

        const selectedKey = renderKeySelect.value;

        // Convert to letter notation if a key is selected (not "numbers")
        if (selectedKey !== 'numbers') {
          song = convertSongToLetters(song, selectedKey);
          song.key = selectedKey;
        }

        renderer.loadSong(song);
        currentPage = 0;
        renderer.renderPage(canvas, currentPage);
        updatePageControls();
      } catch (e) {
        errorEl.textContent = 'Error: ' + e.message;
        errorEl.style.display = 'block';
        console.error(e);
      }
    };

    function convertSongToLetters(song, key) {
      return {
        ...song,
        sections: song.sections.map(section => ({
          ...section,
          lines: section.lines.map(line => ({
            ...line,
            chords: line.chords.map(cp => ({
              ...cp,
              chord: convertChordToLetter(cp.chord, key)
            }))
          }))
        }))
      };
    }

    // Initial render
    render();
  </script>
</body>
</html>
